{
  "abstract": [
    {
      "text": "Combine two images by using alpha blending to create a single output.",
      "type": "text"
    }
  ],
  "hierarchy": {
    "paths": [
      [
        "doc://com.apple.documentation/documentation/technologies",
        "doc://com.apple.accelerate/documentation/Accelerate"
      ],
      [
        "doc://com.apple.documentation/documentation/technologies",
        "doc://com.apple.accelerate/documentation/Accelerate",
        "doc://com.apple.accelerate/documentation/Accelerate/vimage-library"
      ]
    ]
  },
  "identifier": {
    "interfaceLanguage": "swift",
    "url": "doc://com.apple.accelerate/documentation/Accelerate/compositing-images-with-alpha-blending"
  },
  "kind": "article",
  "legalNotices": {
    "copyright": "Copyright &copy; 2025 Apple Inc. All rights reserved.",
    "privacyPolicy": "https://www.apple.com/privacy/privacy-policy",
    "termsOfUse": "https://www.apple.com/legal/internet-services/terms/site.html"
  },
  "metadata": {
    "modules": [
      {
        "name": "Accelerate"
      }
    ],
    "role": "article",
    "roleHeading": "Article",
    "title": "Compositing images with alpha blending"
  },
  "primaryContentSections": [
    {
      "content": [
        {
          "anchor": "overview",
          "level": 2,
          "text": "Overview",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "vImage provides a suite of functions for compositing two source images into one output. ",
              "type": "text"
            },
            {
              "inlineContent": [
                {
                  "text": "Alpha blending",
                  "type": "text"
                }
              ],
              "type": "emphasis"
            },
            {
              "text": " uses the alpha value of each pixel in the top layer to determine the visibility of the bottom layer.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "The figure below shows the alpha composite of an image of a building with a transparent background over an image of a texture. The transparent part of the building image has an alpha of zero, indicating the background layer is fully visible.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "identifier": "media-3696647",
              "type": "image"
            }
          ],
          "type": "paragraph"
        },
        {
          "anchor": "Perform-an-alpha-composite",
          "level": 3,
          "text": "Perform an alpha composite",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "Use the ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.accelerate/documentation/Accelerate/vImagePremultipliedAlphaBlend_ARGB8888(_:_:_:_:)",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " function to blend two images when the top image contains alpha information (for example, when compositing text over a photograph). The images that you pass to ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.accelerate/documentation/Accelerate/vImagePremultipliedAlphaBlend_ARGB8888(_:_:_:_:)",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " need to have the premultiplied alpha information in the first channel.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "The following function performs an alpha composite of two ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.documentation/documentation/coregraphics/cgimage",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " instances and returns the result as a ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.documentation/documentation/coregraphics/cgimage",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " instance:",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "func alphaComposite(topImage: CGImage, bottomImage: CGImage) -> CGImage? {",
            "    // Create source and destination vImage buffers.",
            "    guard",
            "        let topImageBuffer = try? vImage_Buffer(cgImage: topImage),",
            "        let bottomImageBuffer = try? vImage_Buffer(cgImage: bottomImage),",
            "        var destinationImageBuffer = try? vImage_Buffer(size: topImageBuffer.size,",
            "                                                        bitsPerPixel: 8 * 4)",
            "    else {",
            "        return nil",
            "    }",
            "    ",
            "    defer {",
            "        topImageBuffer.free()",
            "        bottomImageBuffer.free()",
            "        destinationImageBuffer.free()",
            "    }",
            "",
            "    withUnsafePointer(to: topImageBuffer) { topPtr in",
            "        withUnsafePointer(to: bottomImageBuffer) { bottomPtr in",
            "            ",
            "            // Ensure the bottom image and top image are ARGB.",
            "            convertToARGB(bottomPtr, alphaInfo: bottomImage.alphaInfo)",
            "            convertToARGB(topPtr, alphaInfo: topImage.alphaInfo)",
            "            ",
            "            // Ensure the top layer is premultiplied.",
            "            premultiply(topPtr, alphaInfo: topImage.alphaInfo)",
            "",
            "            // Perform the composite operation.",
            "            vImagePremultipliedAlphaBlend_ARGB8888(topPtr,",
            "                                                   bottomPtr,",
            "                                                   &destinationImageBuffer,",
            "                                                   vImage_Flags(kvImageNoFlags))",
            "        }",
            "    }",
            "    ",
            "    if let destinationFormat = vImage_CGImageFormat(",
            "        bitsPerComponent: 8,",
            "        bitsPerPixel: 8 * 4,",
            "        colorSpace: CGColorSpaceCreateDeviceRGB(),",
            "        bitmapInfo: CGBitmapInfo(rawValue: CGImageAlphaInfo.first.rawValue)) {",
            "        return try? destinationImageBuffer.createCGImage(format: destinationFormat)",
            "    }",
            "    return nil",
            "}",
            ""
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "Because the blending function ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.accelerate/documentation/Accelerate/vImagePremultipliedAlphaBlend_ARGB8888(_:_:_:_:)",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " requires that the alpha channel source buffers are first, the code calls ",
              "type": "text"
            },
            {
              "code": "convertToARGB(_:alphaInfo:)",
              "type": "codeVoice"
            },
            {
              "text": " to ensure the correct ordering. The ",
              "type": "text"
            },
            {
              "code": "convertToARGB(_:alphaInfo:)",
              "type": "codeVoice"
            },
            {
              "text": " function checks the channel ordering from the source image’s alpha information and permutes the channels if the ordering isn’t alpha-first.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "func convertToARGB(_ buffer: UnsafePointer<vImage_Buffer>,",
            "                   alphaInfo: CGImageAlphaInfo) {",
            "    ",
            "    let alphaLasts = [ CGImageAlphaInfo.last,",
            "                       CGImageAlphaInfo.premultipliedLast,",
            "                       CGImageAlphaInfo.noneSkipLast ]",
            "    ",
            "    if alphaLasts.contains(alphaInfo) {",
            "        vImagePermuteChannels_ARGB8888(buffer,",
            "                                       buffer,",
            "                                       [3, 0, 1, 2],",
            "                                       vImage_Flags(kvImageNoFlags))",
            "    }",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "The ",
              "type": "text"
            },
            {
              "code": "premultiply(_:alphaInfo:)",
              "type": "codeVoice"
            },
            {
              "text": " function uses a ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.documentation/documentation/coregraphics/cgimage",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " instance’s alpha information to determine whether an image contains premultiplied alpha. This function ensures that the top layer that the function passes to the composite operation contains premultiplied pixels.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "func premultiply(_ buffer: UnsafePointer<vImage_Buffer>,",
            "                 alphaInfo: CGImageAlphaInfo) {",
            "    ",
            "    let premultiplieds = [ CGImageAlphaInfo.premultipliedFirst,",
            "                           CGImageAlphaInfo.premultipliedLast ]",
            "    ",
            "    if !premultiplieds.contains(alphaInfo) {",
            "        vImagePremultiplyData_ARGB8888(buffer,",
            "                                       buffer,",
            "                                       vImage_Flags(kvImageNoFlags))",
            "    }",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "anchor": "Perform-an-alpha-composite-with-a-single-alpha-value",
          "level": 3,
          "text": "Perform an alpha composite with a single alpha value",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "vImage provides functions to perform an alpha composite using a single alpha value. The functions apply the constant alpha value you supply combined with the top image’s existing alpha to the top layer’s color channels and alpha channels. For each pixel, the constant alpha functions perform the following operation:",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "destColor = (srcTopColor * constAlpha * 255  + (255*255 - srcTopAlpha * constAlpha) * srcBottomColor + 127*255) / (255*255);",
            "destAlpha =  (srcTopAlpha * constAlpha * 255 + (255*255 - srcTopAlpha * constAlpha) * srcBottomAlpha + 127*255 ) / (255*255);"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "To perform an alpha composite with a constant alpha, replace the call to ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.accelerate/documentation/Accelerate/vImagePremultipliedAlphaBlend_ARGB8888(_:_:_:_:)",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " in the code listing in ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.documentation/documentation/Accelerate/compositing-images-with-alpha-blending#Perform-an-alpha-composite",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " with the following code:",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "// Perform the composite operation.",
            "vImagePremultipliedConstAlphaBlend_ARGB8888(topPtr,",
            "                                            Pixel_8(191),",
            "                                            bottomPtr,",
            "                                            &destinationImageBuffer,",
            "                                            vImage_Flags(kvImageNoFlags))"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "The following image shows the result of compositing with ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.accelerate/documentation/Accelerate/vImagePremultipliedConstAlphaBlend_ARGB8888(_:_:_:_:_:)",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " using a constant alpha with a value of ",
              "type": "text"
            },
            {
              "code": "191",
              "type": "codeVoice"
            },
            {
              "text": ". The background of the building remains transparent, but the parts of the image that were originally opaque now show some of the lower layer.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "identifier": "media-3686488",
              "type": "image"
            }
          ],
          "type": "paragraph"
        },
        {
          "anchor": "Perform-an-alpha-composite-with-an-overwritten-alpha-channel",
          "level": 3,
          "text": "Perform an alpha composite with an overwritten alpha channel",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "Use the ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.accelerate/documentation/Accelerate/vImageOverwriteChannels_ARGB8888(_:_:_:_:_:)",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " function to overwrite an image’s alpha channel. The following shows an example of setting a radial gradient as the alpha channel of an image to produce a vignette style blend:",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "identifier": "media-3702587",
              "type": "image"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "The ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.accelerate/documentation/Accelerate/vImageOverwriteChannels_ARGB8888(_:_:_:_:_:)",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " function requires buffers with nonpremultiplied alpha.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "The ",
              "type": "text"
            },
            {
              "code": "radialComposite(topImage:bottomImage:)",
              "type": "codeVoice"
            },
            {
              "text": " function performs an alpha composite of two ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.documentation/documentation/coregraphics/cgimage",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " instances with a procedural radial gradient.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "func radialComposite(topImage: CGImage,",
            "                     bottomImage: CGImage) -> CGImage? {",
            "    // Create source and destination vImage buffers.",
            "    guard",
            "        let topImageBuffer = try? vImage_Buffer(cgImage: topImage),",
            "        let bottomImageBuffer = try? vImage_Buffer(cgImage: bottomImage),",
            "        var gradientImageBuffer = try? vImage_Buffer(size: topImageBuffer.size,",
            "                                                     bitsPerPixel: 8),",
            "        var destinationImageBuffer = try? vImage_Buffer(size: topImageBuffer.size,",
            "                                                        bitsPerPixel: 8 * 4)",
            "    else {",
            "        return nil",
            "    }",
            "    ",
            "    defer {",
            "        topImageBuffer.free()",
            "        bottomImageBuffer.free()",
            "        gradientImageBuffer.free()",
            "        destinationImageBuffer.free()",
            "    }",
            "    ",
            "    withUnsafePointer(to: topImageBuffer) { topPtr in",
            "        withUnsafePointer(to: bottomImageBuffer) { bottomPtr in",
            "            ",
            "            // Ensure the top image and the bottom image are ARGB.",
            "            convertToARGB(topPtr, alphaInfo: topImage.alphaInfo)",
            "            convertToARGB(bottomPtr, alphaInfo: bottomImage.alphaInfo)",
            "            ",
            "            // Populate `gradientImageBuffer` with a radial gradient.",
            "            makeRadialGradient(&gradientImageBuffer)",
            "            ",
            "            // Unpremultiply before overwriting, if required.",
            "            unpremultiply(topPtr, alphaInfo: topImage.alphaInfo)",
            "            ",
            "            // Overwrite the top layers's alpha channel with the radial gradient.",
            "            vImageOverwriteChannels_ARGB8888(&gradientImageBuffer,",
            "                                             topPtr, topPtr,",
            "                                             0x8,",
            "                                             vImage_Flags(kvImageNoFlags))",
            "            ",
            "            // Premultiply the top layer.",
            "            vImagePremultiplyData_ARGB8888(topPtr, topPtr,",
            "                                           vImage_Flags(kvImageNoFlags))",
            "            ",
            "            // Perform the alpha blend of the top layer over the bottom layer.",
            "            vImagePremultipliedAlphaBlend_ARGB8888(topPtr,",
            "                                                   bottomPtr,",
            "                                                   &destinationImageBuffer,",
            "                                                   vImage_Flags(kvImageNoFlags))",
            "        }",
            "    }",
            "    ",
            "    if let destinationFormat = vImage_CGImageFormat(",
            "        bitsPerComponent: 8,",
            "        bitsPerPixel: 8 * 4,",
            "        colorSpace: CGColorSpaceCreateDeviceRGB(),",
            "        bitmapInfo: CGBitmapInfo(rawValue: CGImageAlphaInfo.first.rawValue)) {",
            "        return try? destinationImageBuffer.createCGImage(format: destinationFormat)",
            "    }",
            "    return nil",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "The code calls ",
              "type": "text"
            },
            {
              "code": "unpremultiply(_:alphaInfo:)",
              "type": "codeVoice"
            },
            {
              "text": " to unpremultiply an image if its alpha information indicates it contains premultiplied pixels.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "func unpremultiply(_ buffer: UnsafePointer<vImage_Buffer>,",
            "                   alphaInfo: CGImageAlphaInfo) {",
            "    ",
            "    let premultiplieds = [ CGImageAlphaInfo.premultipliedFirst,",
            "                           CGImageAlphaInfo.premultipliedLast ]",
            "    ",
            "    if premultiplieds.contains(alphaInfo) {",
            "        vImageUnpremultiplyData_ARGB8888(buffer,",
            "                                         buffer,",
            "                                         vImage_Flags(kvImageNoFlags))",
            "    }",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "The ",
              "type": "text"
            },
            {
              "code": "radialComposite(topImage:bottomImage:)",
              "type": "codeVoice"
            },
            {
              "text": " function calls ",
              "type": "text"
            },
            {
              "code": "makeRadialGradient(_:)",
              "type": "codeVoice"
            },
            {
              "text": " to populate the gradient buffer with a radial gradient. The code generates the radial gradient by multiplying a ",
              "type": "text"
            },
            {
              "code": "height * 1",
              "type": "codeVoice"
            },
            {
              "text": " matrix by a ",
              "type": "text"
            },
            {
              "code": "1 * width",
              "type": "codeVoice"
            },
            {
              "text": " matrix. Both factors contain values that follow a bell-shaped curve.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "func makeRadialGradient(_ destination: inout vImage_Buffer) {",
            "    let width = Int(destination.size.width)",
            "    let height = Int(destination.size.height)",
            "    ",
            "    var gradientValues = [Float](unsafeUninitializedCapacity: width * height) {",
            "        buffer, initializedCount in",
            "        ",
            "        let verticalWindow = vDSP.window(ofType: Float.self,",
            "                                         usingSequence: .hanningDenormalized,",
            "                                         count: height,",
            "                                         isHalfWindow: false)",
            "        ",
            "        let horizontalWindow = vDSP.window(ofType: Float.self,",
            "                                           usingSequence: .hanningDenormalized,",
            "                                           count: width,",
            "                                           isHalfWindow: false)",
            "        ",
            "        vDSP_mmul(verticalWindow, 1,",
            "                  horizontalWindow, 1,",
            "                  buffer.baseAddress!, 1,",
            "                  vDSP_Length(height),",
            "                  vDSP_Length(width), 1)",
            "        ",
            "        initializedCount = width * height",
            "    }.map {",
            "        return Pixel_8($0 * Float(Pixel_8.max))",
            "    }",
            "    ",
            "    gradientValues.withUnsafeMutableBufferPointer { gradientPtr in",
            "        let gradientBuffer = vImage_Buffer(data: gradientPtr.baseAddress,",
            "                                           height: vImagePixelCount(height),",
            "                                           width: vImagePixelCount(width),",
            "                                           rowBytes: width)",
            "        ",
            "        try? gradientBuffer.copy(destinationBuffer: &destination,",
            "                                 pixelSize: 1)",
            "    }",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        }
      ],
      "kind": "content"
    }
  ],
  "references": {
    "doc://com.apple.accelerate/documentation/Accelerate": {
      "abstract": [
        {
          "text": "Make large-scale mathematical computations and image calculations, optimized for high performance and low energy consumption.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate",
      "kind": "symbol",
      "role": "collection",
      "title": "Accelerate",
      "type": "topic",
      "url": "/documentation/accelerate"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/applying-geometric-transforms-to-images": {
      "abstract": [
        {
          "text": "Reflect, shear, rotate, and scale image buffers using vImage.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/applying-geometric-transforms-to-images",
      "kind": "article",
      "role": "article",
      "title": "Applying geometric transforms to images",
      "type": "topic",
      "url": "/documentation/accelerate/applying-geometric-transforms-to-images"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/applying-vimage-operations-to-regions-of-interest": {
      "abstract": [
        {
          "text": "Limit the effect of vImage operations to rectangular regions of interest.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/applying-vimage-operations-to-regions-of-interest",
      "kind": "article",
      "role": "article",
      "title": "Applying vImage operations to regions of interest",
      "type": "topic",
      "url": "/documentation/accelerate/applying-vimage-operations-to-regions-of-interest"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/building-a-basic-image-processing-workflow": {
      "abstract": [
        {
          "text": "Resize an image with vImage.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/building-a-basic-image-processing-workflow",
      "kind": "article",
      "role": "article",
      "title": "Building a Basic Image-Processing Workflow",
      "type": "topic",
      "url": "/documentation/accelerate/building-a-basic-image-processing-workflow"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/compositing-images-with-vimage-blend-modes": {
      "abstract": [
        {
          "text": "Combine two images by using blend modes to create a single output.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/compositing-images-with-vimage-blend-modes",
      "kind": "article",
      "role": "article",
      "title": "Compositing images with vImage blend modes",
      "type": "topic",
      "url": "/documentation/accelerate/compositing-images-with-vimage-blend-modes"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/converting-bitmap-data-between-core-graphics-images-and-vimage-buffers": {
      "abstract": [
        {
          "text": "Pass image data between Core Graphics and vImage to create and manipulate images.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/converting-bitmap-data-between-core-graphics-images-and-vimage-buffers",
      "kind": "article",
      "role": "article",
      "title": "Converting bitmap data between Core Graphics images and vImage buffers",
      "type": "topic",
      "url": "/documentation/accelerate/converting-bitmap-data-between-core-graphics-images-and-vimage-buffers"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/creating-a-core-graphics-image-from-a-vimage-buffer": {
      "abstract": [
        {
          "text": "Create displayable representations of vImage buffers.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/creating-a-core-graphics-image-from-a-vimage-buffer",
      "kind": "article",
      "role": "article",
      "title": "Creating a Core Graphics Image from a vImage Buffer",
      "type": "topic",
      "url": "/documentation/accelerate/creating-a-core-graphics-image-from-a-vimage-buffer"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/creating-and-populating-buffers-from-core-graphics-images": {
      "abstract": [
        {
          "text": "Initialize vImage buffers from Core Graphics images.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/creating-and-populating-buffers-from-core-graphics-images",
      "kind": "article",
      "role": "article",
      "title": "Creating and Populating Buffers from Core Graphics Images",
      "type": "topic",
      "url": "/documentation/accelerate/creating-and-populating-buffers-from-core-graphics-images"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/optimizing-image-processing-performance": {
      "abstract": [
        {
          "text": "Improve your app’s performance by converting image buffer formats from interleaved to planar.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/optimizing-image-processing-performance",
      "kind": "article",
      "role": "article",
      "title": "Optimizing image-processing performance",
      "type": "topic",
      "url": "/documentation/accelerate/optimizing-image-processing-performance"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/vImageOverwriteChannels_ARGB8888(_:_:_:_:_:)": {
      "abstract": [
        {
          "text": "Overwrites the channels of an 8-bit-per-channel, 4-channel interleaved buffer with the corresponding pixels of a planar buffer.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "keyword",
          "text": "func"
        },
        {
          "kind": "text",
          "text": " "
        },
        {
          "kind": "identifier",
          "text": "vImageOverwriteChannels_ARGB8888"
        },
        {
          "kind": "text",
          "text": "("
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "s:SP",
          "text": "UnsafePointer"
        },
        {
          "kind": "text",
          "text": "<"
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@S@vImage_Buffer",
          "text": "vImage_Buffer"
        },
        {
          "kind": "text",
          "text": ">, "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "s:SP",
          "text": "UnsafePointer"
        },
        {
          "kind": "text",
          "text": "<"
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@S@vImage_Buffer",
          "text": "vImage_Buffer"
        },
        {
          "kind": "text",
          "text": ">, "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "s:SP",
          "text": "UnsafePointer"
        },
        {
          "kind": "text",
          "text": "<"
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@S@vImage_Buffer",
          "text": "vImage_Buffer"
        },
        {
          "kind": "text",
          "text": ">, "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "s:s5UInt8V",
          "text": "UInt8"
        },
        {
          "kind": "text",
          "text": ", "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@T@vImage_Flags",
          "text": "vImage_Flags"
        },
        {
          "kind": "text",
          "text": ") -> "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@T@vImage_Error",
          "text": "vImage_Error"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/vImageOverwriteChannels_ARGB8888(_:_:_:_:_:)",
      "kind": "symbol",
      "navigatorTitle": [
        {
          "kind": "identifier",
          "text": "vImageOverwriteChannels_ARGB8888"
        }
      ],
      "role": "symbol",
      "title": "vImageOverwriteChannels_ARGB8888(_:_:_:_:_:)",
      "type": "topic",
      "url": "/documentation/accelerate/vimageoverwritechannels_argb8888(_:_:_:_:_:)"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/vImagePremultipliedAlphaBlend_ARGB8888(_:_:_:_:)": {
      "abstract": [
        {
          "text": "Performs premultiplied alpha compositing of two 8-bit-per-channel, 4-channel ARGB buffers.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "keyword",
          "text": "func"
        },
        {
          "kind": "text",
          "text": " "
        },
        {
          "kind": "identifier",
          "text": "vImagePremultipliedAlphaBlend_ARGB8888"
        },
        {
          "kind": "text",
          "text": "("
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "s:SP",
          "text": "UnsafePointer"
        },
        {
          "kind": "text",
          "text": "<"
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@S@vImage_Buffer",
          "text": "vImage_Buffer"
        },
        {
          "kind": "text",
          "text": ">, "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "s:SP",
          "text": "UnsafePointer"
        },
        {
          "kind": "text",
          "text": "<"
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@S@vImage_Buffer",
          "text": "vImage_Buffer"
        },
        {
          "kind": "text",
          "text": ">, "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "s:SP",
          "text": "UnsafePointer"
        },
        {
          "kind": "text",
          "text": "<"
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@S@vImage_Buffer",
          "text": "vImage_Buffer"
        },
        {
          "kind": "text",
          "text": ">, "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@T@vImage_Flags",
          "text": "vImage_Flags"
        },
        {
          "kind": "text",
          "text": ") -> "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@T@vImage_Error",
          "text": "vImage_Error"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/vImagePremultipliedAlphaBlend_ARGB8888(_:_:_:_:)",
      "kind": "symbol",
      "navigatorTitle": [
        {
          "kind": "identifier",
          "text": "vImagePremultipliedAlphaBlend_ARGB8888"
        }
      ],
      "role": "symbol",
      "title": "vImagePremultipliedAlphaBlend_ARGB8888(_:_:_:_:)",
      "type": "topic",
      "url": "/documentation/accelerate/vimagepremultipliedalphablend_argb8888(_:_:_:_:)"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/vImagePremultipliedConstAlphaBlend_ARGB8888(_:_:_:_:_:)": {
      "abstract": [
        {
          "text": "Performs premultiplied alpha compositing of two 8-bit-per-channel, 4-channel interleaved buffers and applies an extra alpha value to the top buffer.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "keyword",
          "text": "func"
        },
        {
          "kind": "text",
          "text": " "
        },
        {
          "kind": "identifier",
          "text": "vImagePremultipliedConstAlphaBlend_ARGB8888"
        },
        {
          "kind": "text",
          "text": "("
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "s:SP",
          "text": "UnsafePointer"
        },
        {
          "kind": "text",
          "text": "<"
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@S@vImage_Buffer",
          "text": "vImage_Buffer"
        },
        {
          "kind": "text",
          "text": ">, "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@T@Pixel_8",
          "text": "Pixel_8"
        },
        {
          "kind": "text",
          "text": ", "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "s:SP",
          "text": "UnsafePointer"
        },
        {
          "kind": "text",
          "text": "<"
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@S@vImage_Buffer",
          "text": "vImage_Buffer"
        },
        {
          "kind": "text",
          "text": ">, "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "s:SP",
          "text": "UnsafePointer"
        },
        {
          "kind": "text",
          "text": "<"
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@S@vImage_Buffer",
          "text": "vImage_Buffer"
        },
        {
          "kind": "text",
          "text": ">, "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@T@vImage_Flags",
          "text": "vImage_Flags"
        },
        {
          "kind": "text",
          "text": ") -> "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@T@vImage_Error",
          "text": "vImage_Error"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/vImagePremultipliedConstAlphaBlend_ARGB8888(_:_:_:_:_:)",
      "kind": "symbol",
      "navigatorTitle": [
        {
          "kind": "identifier",
          "text": "vImagePremultipliedConstAlphaBlend_ARGB8888"
        }
      ],
      "role": "symbol",
      "title": "vImagePremultipliedConstAlphaBlend_ARGB8888(_:_:_:_:_:)",
      "type": "topic",
      "url": "/documentation/accelerate/vimagepremultipliedconstalphablend_argb8888(_:_:_:_:_:)"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/vimage-library": {
      "abstract": [
        {
          "text": "Manipulate large images using the CPU’s vector processor.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/vimage-library",
      "kind": "article",
      "role": "collectionGroup",
      "title": "vImage",
      "type": "topic",
      "url": "/documentation/accelerate/vimage-library"
    },
    "doc://com.apple.documentation/documentation/Accelerate/compositing-images-with-alpha-blending#Perform-an-alpha-composite": {
      "abstract": [
        {
          "text": "Combine two images by using alpha blending to create a single output.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.documentation/documentation/Accelerate/compositing-images-with-alpha-blending#Perform-an-alpha-composite",
      "kind": "article",
      "role": "article",
      "title": "Compositing images with alpha blending",
      "type": "topic",
      "url": "/documentation/Accelerate/compositing-images-with-alpha-blending"
    },
    "doc://com.apple.documentation/documentation/coregraphics/cgimage": {
      "abstract": [
        {
          "text": "A bitmap image or image mask.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "text",
          "text": "class "
        },
        {
          "kind": "identifier",
          "text": "CGImage"
        }
      ],
      "identifier": "doc://com.apple.documentation/documentation/coregraphics/cgimage",
      "kind": "symbol",
      "role": "symbol",
      "title": "CGImage",
      "type": "topic",
      "url": "/documentation/coregraphics/cgimage"
    },
    "doc://com.apple.documentation/documentation/technologies": {
      "abstract": [
        {
          "text": "",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.documentation/documentation/technologies",
      "kind": "technologies",
      "role": "overview",
      "title": "Technologies",
      "type": "topic",
      "url": "/documentation/technologies"
    },
    "media-3686488": {
      "alt": "A photograph of a skyscraper composited against a rusty metal texture. The metal texture is partially visible through the skyscraper image.",
      "identifier": "media-3686488",
      "type": "image",
      "variants": [
        {
          "traits": [
            "2x",
            "light"
          ],
          "url": "https://docs-assets.developer.apple.com/published/1a0f6a9315bdc2a9620cf80778c602fa/media-3686488@2x.png"
        }
      ]
    },
    "media-3696647": {
      "alt": "Three photographs. Two smaller photographs are stacked on the left and an arrow points to a larger photograph on the right. The photograph on the top left is of a skyscraper against a transparent background. The photograph on the bottom left is of a rusty metal texture. The larger photograph on the right shows the skyscraper composited over the texture.",
      "identifier": "media-3696647",
      "type": "image",
      "variants": [
        {
          "traits": [
            "2x",
            "light"
          ],
          "url": "https://docs-assets.developer.apple.com/published/9e3c715d826010f0a25e9bc74f186e18/media-3696647@2x.png"
        }
      ]
    },
    "media-3702587": {
      "alt": "Four photographs. One  photograph at the top left is of a skyscraper against a transparent background, two  photographs are stacked in the middle, and an arrow points to a photograph on the right. The top-middle photograph is a radial gradient with white at its center and black at the edges, and the bottom-middle photograph is a rusty metal texture. The photograph on the right is a composite with the skyscraper visible at the center, and the rusty metal texture visible at the edge.",
      "identifier": "media-3702587",
      "type": "image",
      "variants": [
        {
          "traits": [
            "2x",
            "light"
          ],
          "url": "https://docs-assets.developer.apple.com/published/9dfd7d16b4f73619038b4fb815bf415c/media-3702587@2x.png"
        }
      ]
    }
  },
  "schemaVersion": {
    "major": 0,
    "minor": 3,
    "patch": 0
  },
  "sections": [],
  "seeAlsoSections": [
    {
      "anchor": "Image-Processing-Essentials",
      "generated": true,
      "identifiers": [
        "doc://com.apple.accelerate/documentation/Accelerate/converting-bitmap-data-between-core-graphics-images-and-vimage-buffers",
        "doc://com.apple.accelerate/documentation/Accelerate/creating-and-populating-buffers-from-core-graphics-images",
        "doc://com.apple.accelerate/documentation/Accelerate/creating-a-core-graphics-image-from-a-vimage-buffer",
        "doc://com.apple.accelerate/documentation/Accelerate/building-a-basic-image-processing-workflow",
        "doc://com.apple.accelerate/documentation/Accelerate/applying-geometric-transforms-to-images",
        "doc://com.apple.accelerate/documentation/Accelerate/compositing-images-with-vimage-blend-modes",
        "doc://com.apple.accelerate/documentation/Accelerate/applying-vimage-operations-to-regions-of-interest",
        "doc://com.apple.accelerate/documentation/Accelerate/optimizing-image-processing-performance",
        "doc://com.apple.accelerate/documentation/Accelerate/vimage-library"
      ],
      "title": "Image Processing Essentials"
    }
  ],
  "variantOverrides": [
    {
      "patch": [
        {
          "op": "replace",
          "path": "/identifier/interfaceLanguage",
          "value": "occ"
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.accelerate~1documentation~1Accelerate~1vImagePremultipliedAlphaBlend_ARGB8888(_:_:_:_:)/title",
          "value": "vImagePremultipliedAlphaBlend_ARGB8888"
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.accelerate~1documentation~1Accelerate~1vImagePremultipliedAlphaBlend_ARGB8888(_:_:_:_:)/fragments",
          "value": [
            {
              "kind": "identifier",
              "text": "vImagePremultipliedAlphaBlend_ARGB8888"
            }
          ]
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.accelerate~1documentation~1Accelerate~1vImageOverwriteChannels_ARGB8888(_:_:_:_:_:)/title",
          "value": "vImageOverwriteChannels_ARGB8888"
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.accelerate~1documentation~1Accelerate~1vImageOverwriteChannels_ARGB8888(_:_:_:_:_:)/fragments",
          "value": [
            {
              "kind": "identifier",
              "text": "vImageOverwriteChannels_ARGB8888"
            }
          ]
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.documentation~1documentation~1coregraphics~1cgimage/title",
          "value": "CGImageRef"
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.accelerate~1documentation~1Accelerate~1vImagePremultipliedConstAlphaBlend_ARGB8888(_:_:_:_:_:)/title",
          "value": "vImagePremultipliedConstAlphaBlend_ARGB8888"
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.accelerate~1documentation~1Accelerate~1vImagePremultipliedConstAlphaBlend_ARGB8888(_:_:_:_:_:)/fragments",
          "value": [
            {
              "kind": "identifier",
              "text": "vImagePremultipliedConstAlphaBlend_ARGB8888"
            }
          ]
        }
      ],
      "traits": [
        {
          "interfaceLanguage": "occ"
        }
      ]
    }
  ]
}
