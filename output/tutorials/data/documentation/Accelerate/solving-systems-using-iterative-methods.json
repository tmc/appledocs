{
  "abstract": [
    {
      "text": "Use iterative methods to solve systems of equations where the coefficient matrix is sparse.",
      "type": "text"
    }
  ],
  "hierarchy": {
    "paths": [
      [
        "doc://com.apple.documentation/documentation/technologies",
        "doc://com.apple.accelerate/documentation/Accelerate"
      ],
      [
        "doc://com.apple.documentation/documentation/technologies",
        "doc://com.apple.accelerate/documentation/Accelerate",
        "doc://com.apple.accelerate/documentation/Accelerate/sparse-solvers-library"
      ]
    ]
  },
  "identifier": {
    "interfaceLanguage": "swift",
    "url": "doc://com.apple.accelerate/documentation/Accelerate/solving-systems-using-iterative-methods"
  },
  "kind": "article",
  "legalNotices": {
    "copyright": "Copyright &copy; 2025 Apple Inc. All rights reserved.",
    "privacyPolicy": "https://www.apple.com/privacy/privacy-policy",
    "termsOfUse": "https://www.apple.com/legal/internet-services/terms/site.html"
  },
  "metadata": {
    "modules": [
      {
        "name": "Accelerate"
      }
    ],
    "role": "article",
    "roleHeading": "Article",
    "title": "Solving systems using iterative methods"
  },
  "primaryContentSections": [
    {
      "content": [
        {
          "anchor": "overview",
          "level": 2,
          "text": "Overview",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "The code in this article solves the following equation by using the iterative method of least squares minimum residual (LSMR) to find the solution.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "identifier": "media-2904629",
              "type": "image"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "In the equation above, ",
              "type": "text"
            },
            {
              "code": "A",
              "type": "codeVoice"
            },
            {
              "text": " refers to the four-by-three matrix, and ",
              "type": "text"
            },
            {
              "code": "b",
              "type": "codeVoice"
            },
            {
              "text": " to the right-hand-side vector. The code in this article solves the equation ",
              "type": "text"
            },
            {
              "code": "Ax = b",
              "type": "codeVoice"
            },
            {
              "text": " by finding ",
              "type": "text"
            },
            {
              "code": "x",
              "type": "codeVoice"
            },
            {
              "text": ".",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "Because ",
              "type": "text"
            },
            {
              "code": "A",
              "type": "codeVoice"
            },
            {
              "text": " is an overdetermined matrix (that is, it has more rows than columns), for most right-hand-sides there isn’t an exact solution. In this case, you usually find the closest solution that minimizes the 2-norm of the error. That is, the solution solves the optimization ",
              "type": "text"
            },
            {
              "code": "min ‖ Ax - b ‖₂",
              "type": "codeVoice"
            },
            {
              "text": ". This is known as the ",
              "type": "text"
            },
            {
              "inlineContent": [
                {
                  "text": "least-squares problem",
                  "type": "text"
                }
              ],
              "type": "emphasis"
            },
            {
              "text": ".",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "You could solve this problem through a direct method, such as sparse QR; however, for some problems, a faster method that provides an adequate solution is the iterative method LSMR. Unlike direct methods that factorize the matrix ",
              "type": "text"
            },
            {
              "code": "A",
              "type": "codeVoice"
            },
            {
              "text": ", iterative methods only require the ability to multiply by the matrix (and its transpose, ",
              "type": "text"
            },
            {
              "code": "Aᵀ",
              "type": "codeVoice"
            },
            {
              "text": "). They move through a sequence of approximate solutions, converging to the correct answer. However, these methods run into numerical difficulties more often than direct methods. Resolving these issues requires expert knowledge, and is sometimes impossible. The most common method to improve and accelerate convergence is to use a preconditioner — an operator that approximates ",
              "type": "text"
            },
            {
              "code": "A⁻¹",
              "type": "codeVoice"
            },
            {
              "text": ". For least-squares problems, using a diagonal matrix with entries equal to the 2-norm of each column is often sufficient and is the method that this article covers.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "anchor": "Create-the-matrix",
          "level": 3,
          "text": "Create the matrix",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "Use the code below — which ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.documentation/documentation/Accelerate/creating-sparse-matrices",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " covers in detail — to define the unsymmetric matrix ",
              "type": "text"
            },
            {
              "code": "A",
              "type": "codeVoice"
            },
            {
              "text": ":",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "tabs": [
            {
              "content": [
                {
                  "code": [
                    "var rowIndices: [Int32] = [0, 1, 3,    // Column 0",
                    "                           0, 1, 2, 3, // Column 1",
                    "                           1, 2]       // Column 2",
                    "",
                    "var columnStarts = [0, 3, 7, 9]",
                    "",
                    "let structure: SparseMatrixStructure = rowIndices.withUnsafeMutableBufferPointer { rowIndicesPtr in",
                    "    columnStarts.withUnsafeMutableBufferPointer { columnStartsPtr in",
                    "        let attributes = SparseAttributes_t()",
                    "        ",
                    "        return SparseMatrixStructure(",
                    "            rowCount: 4,",
                    "            columnCount: 3,",
                    "            columnStarts: columnStartsPtr.baseAddress!,",
                    "            rowIndices: rowIndicesPtr.baseAddress!,",
                    "            attributes: attributes,",
                    "            blockSize: 1",
                    "        )",
                    "    }",
                    "}",
                    "",
                    "var values = [2.0, -0.2, 2.5,          // Column 0",
                    "              1.0, 3.2, -0.1, 1.1,     // Column 1",
                    "              1.4, 0.5]                // Column 2",
                    "",
                    "var xValues = [ 0.0, 0.0, 0.0 ]",
                    "var bValues = [1.200, 1.013, 0.205, -0.172]",
                    "",
                    "values.withUnsafeMutableBufferPointer { valuesPtr in",
                    "    ",
                    "    let a = SparseMatrix_Double(",
                    "        structure: structure,",
                    "        data: valuesPtr.baseAddress!",
                    "    )",
                    "",
                    "[...]"
                  ],
                  "syntax": "swift",
                  "type": "codeListing"
                }
              ],
              "title": "Swift"
            },
            {
              "content": [
                {
                  "code": [
                    "int rowIndices[]    = {   0,    1,   3,   0,   1,    2,   3,   1,   2 };",
                    "double values[]     = { 2.0, -0.2, 2.5, 1.0, 3.2, -0.1, 1.1, 1.4, 0.5 };",
                    " ",
                    "long columnStarts[] = {   0,              3,                   7,        9};",
                    " ",
                    "  SparseMatrix_Double A = {",
                    "    .structure = {",
                    "      .rowCount     = 4,",
                    "      .columnCount  = 3,",
                    "      .columnStarts = columnStarts,",
                    "      .rowIndices   = rowIndices,",
                    "      // Matrix meta-data.",
                    "      .attributes = {",
                    "        .kind = SparseOrdinary,          ",
                    "      },",
                    "      .blockSize = 1",
                    "    },",
                    "    .data = values",
                    "  };"
                  ],
                  "syntax": "objc",
                  "type": "codeListing"
                }
              ],
              "title": "Objective-C"
            }
          ],
          "type": "tabNavigator"
        },
        {
          "anchor": "Solve-the-equation",
          "level": 3,
          "text": "Solve the equation",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "Define the right-hand-side and solution vectors as arrays that you wrap in ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.accelerate/documentation/Accelerate/DenseVector_Double",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " structures. The sparse solve function uses the initial values of ",
              "type": "text"
            },
            {
              "code": "x",
              "type": "codeVoice"
            },
            {
              "text": " as an initial guess of the solution. If you don’t have a good estimate, initialize all the values to zero.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "tabs": [
            {
              "content": [
                {
                  "code": [
                    "[...]",
                    "    ",
                    "    bValues.withUnsafeMutableBufferPointer { bPtr in",
                    "        xValues.withUnsafeMutableBufferPointer { xPtr in",
                    "            let b = DenseVector_Double(",
                    "                count: 4,",
                    "                data: bPtr.baseAddress!",
                    "            )",
                    "            let x = DenseVector_Double(",
                    "                count: 3,",
                    "                data: xPtr.baseAddress!",
                    "            )",
                    "",
                    "[...]"
                  ],
                  "syntax": "swift",
                  "type": "codeListing"
                }
              ],
              "title": "Swift"
            },
            {
              "content": [
                {
                  "code": [
                    "double bValues[] = { 1.200, 1.013, 0.205, -0.172 };",
                    "DenseVector_Double b = {",
                    "    .count = 4,    ",
                    "    .data = bValues ",
                    "  };",
                    " ",
                    "double xValues[] = {   0.0,   0.0,   0.0 };",
                    "DenseVector_Double x = {",
                    "    .count = 3,     ",
                    "    .data = xValues ",
                    "  };"
                  ],
                  "syntax": "objc",
                  "type": "codeListing"
                }
              ],
              "title": "Objective-C"
            }
          ],
          "type": "tabNavigator"
        },
        {
          "inlineContent": [
            {
              "text": "Use the matrix and vectors to perform the full LSMR iteration and iterate over the results in ",
              "type": "text"
            },
            {
              "code": "x",
              "type": "codeVoice"
            },
            {
              "text": ". ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.accelerate/documentation/Accelerate/SparseSolve(_:_:_:_:_:)-5vs11",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " returns a status which, if equal to ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.accelerate/documentation/Accelerate/SparseIterativeConverged",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": ", indicates that the vector, ",
              "type": "text"
            },
            {
              "code": "x",
              "type": "codeVoice"
            },
            {
              "text": ", contains the solution.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "tabs": [
            {
              "content": [
                {
                  "code": [
                    "[...]",
                    "            let status = SparseSolve(SparseLSMR(), a, b, x, SparsePreconditionerDiagScaling)",
                    "            if status != SparseIterativeConverged {",
                    "                fatalError(\"Failed to converge. Returned with error \\(status).\")",
                    "            }",
                    "        }",
                    "    }",
                    "}",
                    "",
                    "print(\"x = \\(xValues)\")"
                  ],
                  "syntax": "swift",
                  "type": "codeListing"
                }
              ],
              "title": "Swift"
            },
            {
              "content": [
                {
                  "code": [
                    "__auto_type status = SparseSolve( SparseLSMR(), A, b, x, SparsePreconditionerDiagScaling);",
                    "if(status!=SparseIterativeConverged) {    ",
                    "    printf(\"Failed to converge. Returned with error %d\\n\", status);}",
                    "else {",
                    "    printf(\"x = \"); ",
                    "    for(int i=0; i<x.count; i++) ",
                    "        printf(\" %.2f\", x.data[i]); printf(\"\\n\");",
                    "}"
                  ],
                  "syntax": "objc",
                  "type": "codeListing"
                }
              ],
              "title": "Objective-C"
            }
          ],
          "type": "tabNavigator"
        },
        {
          "inlineContent": [
            {
              "text": "On return, ",
              "type": "text"
            },
            {
              "code": "x",
              "type": "codeVoice"
            },
            {
              "text": " contains the values  ",
              "type": "text"
            },
            {
              "code": "0.10 0.20 0.30",
              "type": "codeVoice"
            },
            {
              "text": ".",
              "type": "text"
            }
          ],
          "type": "paragraph"
        }
      ],
      "kind": "content"
    }
  ],
  "references": {
    "doc://com.apple.accelerate/documentation/Accelerate": {
      "abstract": [
        {
          "text": "Make large-scale mathematical computations and image calculations, optimized for high performance and low energy consumption.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate",
      "kind": "symbol",
      "role": "collection",
      "title": "Accelerate",
      "type": "topic",
      "url": "/documentation/accelerate"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/DenseVector_Double": {
      "abstract": [
        {
          "text": "A structure that contains a dense vector of double-precision, floating-point values.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "keyword",
          "text": "struct"
        },
        {
          "kind": "text",
          "text": " "
        },
        {
          "kind": "identifier",
          "text": "DenseVector_Double"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/DenseVector_Double",
      "kind": "symbol",
      "navigatorTitle": [
        {
          "kind": "identifier",
          "text": "DenseVector_Double"
        }
      ],
      "role": "symbol",
      "title": "DenseVector_Double",
      "type": "topic",
      "url": "/documentation/accelerate/densevector_double"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/SparseIterativeConverged": {
      "abstract": [
        {
          "text": "A status that indicates the convergence of all solutions.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "keyword",
          "text": "var"
        },
        {
          "kind": "text",
          "text": " "
        },
        {
          "kind": "identifier",
          "text": "SparseIterativeConverged"
        },
        {
          "kind": "text",
          "text": ": "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@EA@SparseIterativeStatus_t",
          "text": "SparseIterativeStatus_t"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/SparseIterativeConverged",
      "kind": "symbol",
      "navigatorTitle": [
        {
          "kind": "identifier",
          "text": "SparseIterativeConverged"
        }
      ],
      "role": "symbol",
      "title": "SparseIterativeConverged",
      "type": "topic",
      "url": "/documentation/accelerate/sparseiterativeconverged"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/SparseSolve(_:_:_:_:_:)-5vs11": {
      "abstract": [
        {
          "text": "Solves the equation ",
          "type": "text"
        },
        {
          "inlineContent": [
            {
              "text": "Ax = b",
              "type": "text"
            }
          ],
          "type": "emphasis"
        },
        {
          "text": " for vectors of double-precision values using the specified iterative method and preconditioner type.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "keyword",
          "text": "func"
        },
        {
          "kind": "text",
          "text": " "
        },
        {
          "kind": "identifier",
          "text": "SparseSolve"
        },
        {
          "kind": "text",
          "text": "("
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@SA@SparseIterativeMethod",
          "text": "SparseIterativeMethod"
        },
        {
          "kind": "text",
          "text": ", "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@SA@SparseMatrix_Double",
          "text": "SparseMatrix_Double"
        },
        {
          "kind": "text",
          "text": ", "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@SA@DenseVector_Double",
          "text": "DenseVector_Double"
        },
        {
          "kind": "text",
          "text": ", "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@SA@DenseVector_Double",
          "text": "DenseVector_Double"
        },
        {
          "kind": "text",
          "text": ", "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@EA@SparsePreconditioner_t",
          "text": "SparsePreconditioner_t"
        },
        {
          "kind": "text",
          "text": ") -> "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:@EA@SparseIterativeStatus_t",
          "text": "SparseIterativeStatus_t"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/SparseSolve(_:_:_:_:_:)-5vs11",
      "kind": "symbol",
      "navigatorTitle": [
        {
          "kind": "identifier",
          "text": "SparseSolve"
        }
      ],
      "role": "symbol",
      "title": "SparseSolve(_:_:_:_:_:)",
      "type": "topic",
      "url": "/documentation/accelerate/sparsesolve(_:_:_:_:_:)-5vs11"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/creating-a-sparse-matrix-from-coordinate-format-arrays": {
      "abstract": [
        {
          "text": "Use separate coordinate format arrays to create sparse matrices.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/creating-a-sparse-matrix-from-coordinate-format-arrays",
      "kind": "article",
      "role": "article",
      "title": "Creating a sparse matrix from coordinate format arrays",
      "type": "topic",
      "url": "/documentation/accelerate/creating-a-sparse-matrix-from-coordinate-format-arrays"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/creating-sparse-matrices": {
      "abstract": [
        {
          "text": "Create sparse matrices for factorization and solving systems.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/creating-sparse-matrices",
      "kind": "article",
      "role": "article",
      "title": "Creating sparse matrices",
      "type": "topic",
      "url": "/documentation/accelerate/creating-sparse-matrices"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/solving-systems-using-direct-methods": {
      "abstract": [
        {
          "text": "Use direct methods to solve systems of equations where the coefficient matrix is sparse.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/solving-systems-using-direct-methods",
      "kind": "article",
      "role": "article",
      "title": "Solving systems using direct methods",
      "type": "topic",
      "url": "/documentation/accelerate/solving-systems-using-direct-methods"
    },
    "doc://com.apple.accelerate/documentation/Accelerate/sparse-solvers-library": {
      "abstract": [
        {
          "text": "Solve systems of equations where the coefficient matrix is sparse.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.accelerate/documentation/Accelerate/sparse-solvers-library",
      "kind": "article",
      "role": "collectionGroup",
      "title": "Sparse Solvers",
      "type": "topic",
      "url": "/documentation/accelerate/sparse-solvers-library"
    },
    "doc://com.apple.documentation/documentation/Accelerate/creating-sparse-matrices": {
      "abstract": [
        {
          "text": "Create sparse matrices for factorization and solving systems.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.documentation/documentation/Accelerate/creating-sparse-matrices",
      "kind": "article",
      "role": "article",
      "title": "Creating sparse matrices",
      "type": "topic",
      "url": "/documentation/Accelerate/creating-sparse-matrices"
    },
    "doc://com.apple.documentation/documentation/technologies": {
      "abstract": [
        {
          "text": "",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.documentation/documentation/technologies",
      "kind": "technologies",
      "role": "overview",
      "title": "Technologies",
      "type": "topic",
      "url": "/documentation/technologies"
    },
    "media-2904629": {
      "alt": "A mathematical equation that consists of a four-by-three matrix with three empty elements multiplied by the four-element vector of unknown values, x, that equals a four-element vector of known values.",
      "identifier": "media-2904629",
      "type": "image",
      "variants": [
        {
          "traits": [
            "2x",
            "light"
          ],
          "url": "https://docs-assets.developer.apple.com/published/fb5a8b83d2f4620c55f66124efb9e7f8/media-2904629@2x.png"
        }
      ]
    }
  },
  "schemaVersion": {
    "major": 0,
    "minor": 3,
    "patch": 0
  },
  "sections": [],
  "seeAlsoSections": [
    {
      "anchor": "Sparse-Matrices",
      "generated": true,
      "identifiers": [
        "doc://com.apple.accelerate/documentation/Accelerate/creating-sparse-matrices",
        "doc://com.apple.accelerate/documentation/Accelerate/solving-systems-using-direct-methods",
        "doc://com.apple.accelerate/documentation/Accelerate/creating-a-sparse-matrix-from-coordinate-format-arrays",
        "doc://com.apple.accelerate/documentation/Accelerate/sparse-solvers-library"
      ],
      "title": "Sparse Matrices"
    }
  ],
  "variantOverrides": [
    {
      "patch": [
        {
          "op": "replace",
          "path": "/identifier/interfaceLanguage",
          "value": "occ"
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.accelerate~1documentation~1Accelerate~1DenseVector_Double/title",
          "value": "DenseVector_Double"
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.accelerate~1documentation~1Accelerate~1DenseVector_Double/fragments",
          "value": [
            {
              "kind": "identifier",
              "text": "DenseVector_Double"
            }
          ]
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.accelerate~1documentation~1Accelerate~1DenseVector_Double/navigatorTitle",
          "value": [
            {
              "kind": "identifier",
              "text": "DenseVector_Double"
            }
          ]
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.accelerate~1documentation~1Accelerate~1SparseIterativeConverged/title",
          "value": "SparseIterativeConverged"
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.accelerate~1documentation~1Accelerate~1SparseIterativeConverged/fragments",
          "value": [
            {
              "kind": "identifier",
              "text": "SparseIterativeConverged"
            }
          ]
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.accelerate~1documentation~1Accelerate~1SparseSolve(_:_:_:_:_:)-5vs11/title",
          "value": "SparseSolve"
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.accelerate~1documentation~1Accelerate~1SparseSolve(_:_:_:_:_:)-5vs11/fragments",
          "value": [
            {
              "kind": "identifier",
              "text": "SparseSolve"
            }
          ]
        }
      ],
      "traits": [
        {
          "interfaceLanguage": "occ"
        }
      ]
    }
  ]
}
