{
  "abstract": [
    {
      "text": "Make your custom types easier to use by ensuring that they conform to Swift protocols.",
      "type": "text"
    }
  ],
  "hierarchy": {
    "paths": [
      [
        "doc://com.apple.documentation/documentation/technologies",
        "doc://com.apple.Swift/documentation/Swift"
      ]
    ]
  },
  "identifier": {
    "interfaceLanguage": "swift",
    "url": "doc://com.apple.Swift/documentation/Swift/adopting-common-protocols"
  },
  "kind": "article",
  "legalNotices": {
    "copyright": "Copyright &copy; 2025 Apple Inc. All rights reserved.",
    "privacyPolicy": "https://www.apple.com/privacy/privacy-policy",
    "termsOfUse": "https://www.apple.com/legal/internet-services/terms/site.html"
  },
  "metadata": {
    "modules": [
      {
        "name": "Swift"
      }
    ],
    "role": "article",
    "roleHeading": "Article",
    "title": "Adopting Common Protocols"
  },
  "primaryContentSections": [
    {
      "content": [
        {
          "anchor": "Overview",
          "level": 2,
          "text": "Overview",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "When using custom types to model data in your programs, you may frequently need to",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "check whether two values are the same or different, or whether a particular value",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "is included in a list of values. This capability, as well as the ability to store",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "values in a set or use them as keys in a dictionary, are governed by two related",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "standard library protocols, ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.Swift/documentation/Swift/Equatable",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " and ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.Swift/documentation/Swift/Hashable",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": ".",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "items": [
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "text": "You can compare instances of an ",
                      "type": "text"
                    },
                    {
                      "inlineContent": [
                        {
                          "text": "equatable",
                          "type": "text"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "text": " type by using the equal-to (",
                      "type": "text"
                    },
                    {
                      "code": "==",
                      "type": "codeVoice"
                    },
                    {
                      "text": ") and",
                      "type": "text"
                    },
                    {
                      "text": " ",
                      "type": "text"
                    },
                    {
                      "text": "not-equal-to (",
                      "type": "text"
                    },
                    {
                      "code": "!=",
                      "type": "codeVoice"
                    },
                    {
                      "text": ") operators.",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            },
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "text": "An instance of a ",
                      "type": "text"
                    },
                    {
                      "inlineContent": [
                        {
                          "text": "hashable",
                          "type": "text"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "text": " type can reduce its value mathematically to a single",
                      "type": "text"
                    },
                    {
                      "text": " ",
                      "type": "text"
                    },
                    {
                      "text": "integer, which is used internally by sets and dictionaries to make lookups consistently",
                      "type": "text"
                    },
                    {
                      "text": " ",
                      "type": "text"
                    },
                    {
                      "text": "fast.",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            }
          ],
          "type": "unorderedList"
        },
        {
          "inlineContent": [
            {
              "text": "Many standard library types are both equatable and hashable, including strings, integers,",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "floating-point values, Boolean values, and collections of equatable and hashable",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "types. The ",
              "type": "text"
            },
            {
              "code": "==",
              "type": "codeVoice"
            },
            {
              "text": " comparison and the ",
              "type": "text"
            },
            {
              "code": "contains(_:)",
              "type": "codeVoice"
            },
            {
              "text": " method call in the following example",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "depend on strings and integers being equatable:",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "if username == \"Arturo\" {",
            "    print(\"Hi, Arturo!\")",
            "}",
            "",
            "let favoriteNumbers = [4, 7, 8, 9]",
            "if favoriteNumbers.contains(todaysDate.day) {",
            "    print(\"It's a good day today!\")",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "Conforming to the ",
              "type": "text"
            },
            {
              "code": "Equatable",
              "type": "codeVoice"
            },
            {
              "text": " and ",
              "type": "text"
            },
            {
              "code": "Hashable",
              "type": "codeVoice"
            },
            {
              "text": " protocols is straightforward and makes",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "it easier to use your own types in Swift. It’s a good idea for all your custom model",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "types to conform.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "anchor": "Conform-Automatically-to-Equatable-and-Hashable",
          "level": 3,
          "text": "Conform Automatically to Equatable and Hashable",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "You can make many custom types equatable and hashable by simply declaring these protocol",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "conformances in the same file as the type’s original declaration. Add ",
              "type": "text"
            },
            {
              "code": "Equatable",
              "type": "codeVoice"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "and ",
              "type": "text"
            },
            {
              "code": "Hashable",
              "type": "codeVoice"
            },
            {
              "text": " to the list of adopted protocols when declaring the type, and the",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "compiler automatically fills in the requirements for the two protocols:",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "/// A position in an x-y coordinate system.",
            "struct Position: Equatable, Hashable {",
            "    var x: Int",
            "    var y: Int",
            "",
            "    init(_ x: Int, _ y: Int) {",
            "        self.x = x",
            "        self.y = y",
            "    }",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "With ",
              "type": "text"
            },
            {
              "code": "Equatable",
              "type": "codeVoice"
            },
            {
              "text": " conformance, you can use the equal-to operator (",
              "type": "text"
            },
            {
              "code": "==",
              "type": "codeVoice"
            },
            {
              "text": ") or the not-equal-to",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "operator (",
              "type": "text"
            },
            {
              "code": "!=",
              "type": "codeVoice"
            },
            {
              "text": ") with any two instances of the ",
              "type": "text"
            },
            {
              "code": "Position",
              "type": "codeVoice"
            },
            {
              "text": " type.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "let availablePositions = [Position(0, 0), Position(0, 1), Position(1, 0)]",
            "let gemPosition = Position(1, 0)",
            "",
            "for position in availablePositions {",
            "    if gemPosition == position {",
            "        print(\"Gem found at (\\(position.x), \\(position.y))!\")",
            "    } else {",
            "        print(\"No gem at (\\(position.x), \\(position.y))\")",
            "    }",
            "}",
            "// No gem at (0, 0)",
            "// No gem at (0, 1)",
            "// Gem found at (1, 0)!",
            ""
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "code": "Hashable",
              "type": "codeVoice"
            },
            {
              "text": " conformance means that you can store positions in a set and quickly check",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "whether you’ve visited a position before, as shown in the following example:",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "var visitedPositions: Set = [Position(0, 0), Position(1, 0)]",
            "let currentPosition = Position(1, 3)",
            "",
            "if visitedPositions.contains(currentPosition) {",
            "    print(\"Already visited (\\(currentPosition.x), \\(currentPosition.y))\")",
            "} else {",
            "    print(\"First time at (\\(currentPosition.x), \\(currentPosition.y))\")",
            "    visitedPositions.insert(currentPosition)",
            "}",
            "// First time at (1, 3)",
            ""
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "In addition to simplifying your code, this automatic conformance reduces errors,",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "because any new properties you add to your custom types are automatically included",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "when hashing and testing for equality. A type is eligible for automatic conformance",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "to ",
              "type": "text"
            },
            {
              "code": "Equatable",
              "type": "codeVoice"
            },
            {
              "text": " and ",
              "type": "text"
            },
            {
              "code": "Hashable",
              "type": "codeVoice"
            },
            {
              "text": " when it’s a structure or an enumeration that meets",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "these criteria:",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "items": [
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "text": "For a structure, ",
                      "type": "text"
                    },
                    {
                      "inlineContent": [
                        {
                          "text": "all",
                          "type": "text"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "text": " its stored properties must conform to ",
                      "type": "text"
                    },
                    {
                      "code": "Equatable",
                      "type": "codeVoice"
                    },
                    {
                      "text": " and ",
                      "type": "text"
                    },
                    {
                      "code": "Hashable",
                      "type": "codeVoice"
                    },
                    {
                      "text": ".",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            },
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "text": "For an enumeration, ",
                      "type": "text"
                    },
                    {
                      "inlineContent": [
                        {
                          "text": "all",
                          "type": "text"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "text": " its associated values must conform to ",
                      "type": "text"
                    },
                    {
                      "code": "Equatable",
                      "type": "codeVoice"
                    },
                    {
                      "text": " and",
                      "type": "text"
                    },
                    {
                      "text": " ",
                      "type": "text"
                    },
                    {
                      "code": "Hashable",
                      "type": "codeVoice"
                    },
                    {
                      "text": ". (Enumerations without associated values have ",
                      "type": "text"
                    },
                    {
                      "code": "Equatable",
                      "type": "codeVoice"
                    },
                    {
                      "text": " and ",
                      "type": "text"
                    },
                    {
                      "code": "Hashable",
                      "type": "codeVoice"
                    },
                    {
                      "text": " ",
                      "type": "text"
                    },
                    {
                      "text": "conformance even without declaring adoption.)",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            }
          ],
          "type": "unorderedList"
        },
        {
          "anchor": "Conform-Manually-to-Equatable-and-Hashable",
          "level": 3,
          "text": "Conform Manually to Equatable and Hashable",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "You need to manually implement ",
              "type": "text"
            },
            {
              "code": "Equatable",
              "type": "codeVoice"
            },
            {
              "text": " and ",
              "type": "text"
            },
            {
              "code": "Hashable",
              "type": "codeVoice"
            },
            {
              "text": " conformance for a type",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "in these cases:",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "items": [
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "text": "The type doesn’t meet the criteria listed in the previous section.",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            },
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "text": "You want to customize the type’s conformance.",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            },
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "text": "You want to extend a type declared in another file or module to conform.",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            }
          ],
          "type": "unorderedList"
        },
        {
          "code": [
            "class Player {",
            "    var name: String",
            "    var position: Position",
            "",
            "    init(name: String, position: Position) {",
            "        self.name = name",
            "        self.position = position",
            "    }",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "The ",
              "type": "text"
            },
            {
              "code": "Player",
              "type": "codeVoice"
            },
            {
              "text": " type is a class, so it doesn’t qualify for automatic synthesis of the",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "code": "Equatable",
              "type": "codeVoice"
            },
            {
              "text": " or ",
              "type": "text"
            },
            {
              "code": "Hashable",
              "type": "codeVoice"
            },
            {
              "text": " requirements. To make this class conform to the ",
              "type": "text"
            },
            {
              "code": "Equatable",
              "type": "codeVoice"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "protocol, declare conformance in an extension and implement the  static ",
              "type": "text"
            },
            {
              "code": "==",
              "type": "codeVoice"
            },
            {
              "text": " operator",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "method. Compare each significant property for equality in your ",
              "type": "text"
            },
            {
              "code": "==",
              "type": "codeVoice"
            },
            {
              "text": " method’s implementation:",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "extension Player: Equatable {",
            "    static func ==(lhs: Player, rhs: Player) -> Bool {",
            "        return lhs.name == rhs.name && lhs.position == rhs.position",
            "    }",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "To make ",
              "type": "text"
            },
            {
              "code": "Player",
              "type": "codeVoice"
            },
            {
              "text": " conform to the ",
              "type": "text"
            },
            {
              "code": "Hashable",
              "type": "codeVoice"
            },
            {
              "text": " protocol, declare conformance in another",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "extension and implement the ",
              "type": "text"
            },
            {
              "code": "hash(into:)",
              "type": "codeVoice"
            },
            {
              "text": " method. In the ",
              "type": "text"
            },
            {
              "code": "hash(into:)",
              "type": "codeVoice"
            },
            {
              "text": " method, call",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "the ",
              "type": "text"
            },
            {
              "code": "combine(_:)",
              "type": "codeVoice"
            },
            {
              "text": " method on the provided hasher with each significant property:",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "extension Player: Hashable {",
            "    func hash(into hasher: inout Hasher) {",
            "        hasher.combine(name)",
            "        hasher.combine(position)",
            "    }",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "anchor": "Use-All-Significant-Properties-for-Equatable-and-Hashable",
          "level": 4,
          "text": "Use All Significant Properties for Equatable and Hashable",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "When implementing the ",
              "type": "text"
            },
            {
              "code": "==",
              "type": "codeVoice"
            },
            {
              "text": " method and the ",
              "type": "text"
            },
            {
              "code": "hash(into:)",
              "type": "codeVoice"
            },
            {
              "text": " method, use all the properties",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "that affect whether two instances of your custom type are considered equal. In the",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "implementations above, the ",
              "type": "text"
            },
            {
              "code": "Player",
              "type": "codeVoice"
            },
            {
              "text": " type uses ",
              "type": "text"
            },
            {
              "code": "name",
              "type": "codeVoice"
            },
            {
              "text": " and ",
              "type": "text"
            },
            {
              "code": "position",
              "type": "codeVoice"
            },
            {
              "text": " in both methods.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "If your type contains properties that don’t affect whether two instances are considered",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "equal, exclude those properties from comparison in the ",
              "type": "text"
            },
            {
              "code": "==",
              "type": "codeVoice"
            },
            {
              "text": " method and from hashing",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "in ",
              "type": "text"
            },
            {
              "code": "hash(into:)",
              "type": "codeVoice"
            },
            {
              "text": ". For example, a type might cache an expensive computed value so",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "that it only needs to calculate it once. If you compare two instances of that type,",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "whether or not the computed value has been cached shouldn’t affect their equality,",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "so the cached value should be excluded from comparison and hashing.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "content": [
            {
              "inlineContent": [
                {
                  "text": "Always use the same properties in both your ",
                  "type": "text"
                },
                {
                  "code": "==",
                  "type": "codeVoice"
                },
                {
                  "text": " and ",
                  "type": "text"
                },
                {
                  "code": "hash(into:)",
                  "type": "codeVoice"
                },
                {
                  "text": " methods.",
                  "type": "text"
                },
                {
                  "text": " ",
                  "type": "text"
                },
                {
                  "text": "Using different groups of properties in the two methods can lead to unexpected behavior",
                  "type": "text"
                },
                {
                  "text": " ",
                  "type": "text"
                },
                {
                  "text": "or performance when using your custom type in sets and dictionaries.",
                  "type": "text"
                }
              ],
              "type": "paragraph"
            }
          ],
          "name": "Important",
          "style": "important",
          "type": "aside"
        },
        {
          "anchor": "Customize-NSObject-Subclass-Behavior",
          "level": 3,
          "text": "Customize NSObject Subclass Behavior",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "code": "NSObject",
              "type": "codeVoice"
            },
            {
              "text": " subclasses inherit conformance to the ",
              "type": "text"
            },
            {
              "code": "Equatable",
              "type": "codeVoice"
            },
            {
              "text": " and ",
              "type": "text"
            },
            {
              "code": "Hashable",
              "type": "codeVoice"
            },
            {
              "text": " protocols,",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "with equality based on instance identity. If you need to customize this behavior,",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "override the ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.documentation/documentation/objectivec/nsobjectprotocol/1418795-isequal",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "method and ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.documentation/documentation/objectivec/nsobjectprotocol/1418859-hash",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "property instead of the ",
              "type": "text"
            },
            {
              "code": "==",
              "type": "codeVoice"
            },
            {
              "text": " operator method and ",
              "type": "text"
            },
            {
              "code": "hashValue",
              "type": "codeVoice"
            },
            {
              "text": " property.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "extension MyNSObjectSubclass {",
            "    override func isEqual(_ object: Any?) -> Bool {",
            "        guard let other = object as? MyNSObjectSubclass",
            "            else { return false }",
            "        return self.firstProperty == other.firstProperty ",
            "            && self.secondProperty == other.secondProperty",
            "    }",
            "",
            "    override var hash: Int {",
            "        var hasher = Hasher()",
            "        hasher.combine(firstProperty)",
            "        hasher.combine(secondProperty)",
            "        return hasher.finalize()",
            "    }",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "As noted in the previous section, two instances that are considered equal must have",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "the same hash value. If you override one of these declarations, you must also override",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "the other to maintain that guarantee.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        }
      ],
      "kind": "content"
    }
  ],
  "references": {
    "Swift-PageImage-card.png": {
      "alt": "An orange Swift logo on a gradient background.",
      "identifier": "Swift-PageImage-card.png",
      "type": "image",
      "variants": [
        {
          "traits": [
            "2x",
            "light"
          ],
          "url": "https://docs-assets.developer.apple.com/published/81257762cf893d205c049e3021340e5f/Swift-PageImage-card@2x.png"
        },
        {
          "traits": [
            "2x",
            "dark"
          ],
          "url": "https://docs-assets.developer.apple.com/published/4d2ed632470b4616483901941fae4098/Swift-PageImage-card~dark@2x.png"
        }
      ]
    },
    "doc://com.apple.Swift/documentation/Swift": {
      "abstract": [
        {
          "text": "Build apps using a powerful open language.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.Swift/documentation/Swift",
      "images": [
        {
          "identifier": "Swift-PageImage-card.png",
          "type": "card"
        }
      ],
      "kind": "symbol",
      "role": "collection",
      "title": "Swift",
      "type": "topic",
      "url": "/documentation/swift"
    },
    "doc://com.apple.Swift/documentation/Swift/Equatable": {
      "abstract": [
        {
          "text": "A type that can be compared for value equality.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "keyword",
          "text": "protocol"
        },
        {
          "kind": "text",
          "text": " "
        },
        {
          "kind": "identifier",
          "text": "Equatable"
        }
      ],
      "identifier": "doc://com.apple.Swift/documentation/Swift/Equatable",
      "kind": "symbol",
      "navigatorTitle": [
        {
          "kind": "identifier",
          "text": "Equatable"
        }
      ],
      "role": "symbol",
      "title": "Equatable",
      "type": "topic",
      "url": "/documentation/swift/equatable"
    },
    "doc://com.apple.Swift/documentation/Swift/Hashable": {
      "abstract": [
        {
          "text": "A type that can be hashed into a ",
          "type": "text"
        },
        {
          "code": "Hasher",
          "type": "codeVoice"
        },
        {
          "text": " to produce an integer hash value.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "keyword",
          "text": "protocol"
        },
        {
          "kind": "text",
          "text": " "
        },
        {
          "kind": "identifier",
          "text": "Hashable"
        }
      ],
      "identifier": "doc://com.apple.Swift/documentation/Swift/Hashable",
      "kind": "symbol",
      "navigatorTitle": [
        {
          "kind": "identifier",
          "text": "Hashable"
        }
      ],
      "role": "symbol",
      "title": "Hashable",
      "type": "topic",
      "url": "/documentation/swift/hashable"
    },
    "doc://com.apple.Swift/documentation/Swift/choosing-between-structures-and-classes": {
      "abstract": [
        {
          "text": "Decide how to store data and model behavior.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.Swift/documentation/Swift/choosing-between-structures-and-classes",
      "kind": "article",
      "role": "article",
      "title": "Choosing Between Structures and Classes",
      "type": "topic",
      "url": "/documentation/swift/choosing-between-structures-and-classes"
    },
    "doc://com.apple.documentation/documentation/objectivec/nsobjectprotocol/1418795-isequal": {
      "abstract": [
        {
          "text": "Returns a Boolean value that indicates whether the receiver and a given object are equal.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "text",
          "text": "func "
        },
        {
          "kind": "identifier",
          "text": "isEqual"
        },
        {
          "kind": "text",
          "text": "(Any?) -> Bool"
        }
      ],
      "identifier": "doc://com.apple.documentation/documentation/objectivec/nsobjectprotocol/1418795-isequal",
      "kind": "symbol",
      "role": "symbol",
      "title": "isEqual(_:)",
      "type": "topic",
      "url": "/documentation/objectivec/nsobjectprotocol/1418795-isequal"
    },
    "doc://com.apple.documentation/documentation/objectivec/nsobjectprotocol/1418859-hash": {
      "abstract": [
        {
          "text": "Returns an integer that can be used as a table address in a hash table structure.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "text",
          "text": "var "
        },
        {
          "kind": "identifier",
          "text": "hash"
        },
        {
          "kind": "text",
          "text": ": Int"
        }
      ],
      "identifier": "doc://com.apple.documentation/documentation/objectivec/nsobjectprotocol/1418859-hash",
      "kind": "symbol",
      "role": "symbol",
      "title": "hash",
      "type": "topic",
      "url": "/documentation/objectivec/nsobjectprotocol/1418859-hash"
    },
    "doc://com.apple.documentation/documentation/technologies": {
      "abstract": [
        {
          "text": "",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.documentation/documentation/technologies",
      "kind": "technologies",
      "role": "overview",
      "title": "Technologies",
      "type": "topic",
      "url": "/documentation/technologies"
    }
  },
  "schemaVersion": {
    "major": 0,
    "minor": 3,
    "patch": 0
  },
  "sections": [],
  "seeAlsoSections": [
    {
      "anchor": "Data-Modeling",
      "generated": true,
      "identifiers": [
        "doc://com.apple.Swift/documentation/Swift/choosing-between-structures-and-classes"
      ],
      "title": "Data Modeling"
    }
  ],
  "variantOverrides": [
    {
      "patch": [
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.documentation~1documentation~1objectivec~1nsobjectprotocol~11418795-isequal/title",
          "value": "isEqual:"
        }
      ],
      "traits": [
        {
          "interfaceLanguage": "occ"
        }
      ]
    }
  ]
}
