{
  "abstract": [
    {
      "text": "Remove coupling between components to increase test coverage and reliability.",
      "type": "text"
    }
  ],
  "hierarchy": {
    "paths": [
      [
        "doc://com.apple.documentation/documentation/technologies",
        "doc://com.apple.Xcode/documentation/Xcode",
        "doc://com.apple.Xcode/documentation/Xcode/testing"
      ]
    ]
  },
  "identifier": {
    "interfaceLanguage": "swift",
    "url": "doc://com.apple.Xcode/documentation/Xcode/updating-your-existing-codebase-to-accommodate-unit-tests"
  },
  "kind": "article",
  "legalNotices": {
    "copyright": "Copyright &copy; 2025 Apple Inc. All rights reserved.",
    "privacyPolicy": "https://www.apple.com/privacy/privacy-policy",
    "termsOfUse": "https://www.apple.com/legal/internet-services/terms/site.html"
  },
  "metadata": {
    "role": "article",
    "roleHeading": "Article",
    "title": "Updating your existing codebase to accommodate unit tests"
  },
  "primaryContentSections": [
    {
      "content": [
        {
          "anchor": "Overview",
          "level": 2,
          "text": "Overview",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "Adding unit tests to existing projects can be difficult, because design choices made without",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "considering testability can couple together distinct classes or subsystems, making",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "it impossible to test them in isolation. When two components in your software are",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "tightly coupled, you can only use one of them correctly when it’s integrated with",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "the other in a specific way. Sometimes, this coupling means your tests attempt",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "network connections or interact with the filesystem, which makes the tests slow",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "and their results non-deterministic. Removing the coupling makes it possible to",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "introduce unit tests, but requires code changes in places where you don’t already",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "have test coverage, which is risky.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "To improve the test coverage of your project by identifying a component you’d like to",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "test, write a test case that covers the behavior you want to assert. Use a",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "risk-focused approach to prioritization that covers logic in features which have",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "received a high number of user bug reports, or where a regression would have the",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "highest impact.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "When the code you’re testing is coupled to another part of your project or a framework",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "class, make the smallest possible change to the code so you can isolate the component",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "without changing its behavior. Improve the ability to use the class in a test context",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "with reduced coupling, and keep the changes small to reduce the risk associated with",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "each change.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "The following sections propose changes that remove couplings in situations where",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "coupling between the code under consideration and another component blocks testing.",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "Each solution demonstrates how a test function works with the changed code to assert",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "its behavior.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "anchor": "Replace-a-concrete-type-with-a-protocol",
          "level": 3,
          "text": "Replace a concrete type with a protocol",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "When your code relies on a specific type whose behavior makes testing difficult,",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "create a protocol that lists the methods and properties used by your code. You can",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "use this approach when interacting with components in your own codebase or with",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "APIs from other sources outside of your control, including platform SDKs and Swift",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "packages. Examples of such problematic dependencies include those that access",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "external state, including user documents or databases, or those that don’t have",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "deterministic results, including network connections or random value generators.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "The following shows a class in an app that uses an opaque service to open",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "a file which represents an attachment handled by external dependancies. The",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "outcome of the ",
              "type": "text"
            },
            {
              "code": "openAttachment(file:with:)",
              "type": "codeVoice"
            },
            {
              "text": " method depends on whether the opaque",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "service can handle files of the requested type, and whether the application",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "successfully opens the file. All of these variables could introduce test failures,",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "which would slow down development as you investigate “errors” that turn out to be",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "transient problems unrelated to your code.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "private enum AttachmentOpeningError: Error {",
            "    case unableToOpenAttachment",
            "}",
            "",
            "struct AttachmentOpener {",
            "  func openAttachment(file location: URL, with service: OpaqueService) throws {",
            "    if (!service.open(location)) {",
            "      throw AttachmentOpeningError.unableToOpenAttachment",
            "    }",
            "  }",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "To test code with this coupling, introduce a protocol that describes how your code",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "interacts with the problematic dependency. Use that protocol in your code, so the",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "class depends on the existence of the methods in the protocol, but not their specific",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "implementation. Write an alternative implementation of the protocol that doesn’t",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "perform the stateful or nondeterministic tasks, and use that implementation to write",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "tests with controlled behavior.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "In this listing, a protocol that includes the ",
              "type": "text"
            },
            {
              "code": "open",
              "type": "codeVoice"
            },
            {
              "text": " method is defined, along",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "with an extension to opaque class that makes it conform to the protocol.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "protocol URLOpener {",
            "    func open(_ file: URL) -> Bool",
            "}",
            "",
            "extension OpaqueService : URLOpener {}",
            "",
            "struct AttachmentOpener {",
            "    func openAttachment(file location: URL, with service: URLOpener) throws {",
            "        if (!service.open(location)) {",
            "            throw AttachmentOpeningError.unableToOpenAttachment",
            "        }",
            "    }",
            "}",
            "",
            "class StubService: URLOpener {",
            "    var isSuccessful = true",
            "",
            "    func open(_ file: URL) -> Bool {",
            "        return isSuccessful",
            "    }",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "In tests, write a different implementation of the ",
              "type": "text"
            },
            {
              "code": "URLOpener",
              "type": "codeVoice"
            },
            {
              "text": " protocol that doesn’t",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "depend on the apps installed on the user’s computer.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "tabs": [
            {
              "content": [
                {
                  "code": [
                    "@Suite struct AttachmentOpenerTests {",
                    "    var service = StubService()",
                    "    var attachmentOpener = AttachmentOpener()",
                    "    let location = URL(fileURLWithPath: \"/tmp/a_file.txt\")",
                    "",
                    "    @Test(\"throws no error when open succeeds\")",
                    "    func serviceCanOpenAttachment() {",
                    "        service.isSuccessful = true",
                    "        #expect(throws: Never.self) {",
                    "            try attachmentOpener.openAttachment(file: location, with: service)",
                    "        }",
                    "    }",
                    "",
                    "",
                    "    @Test(\"throws unableToOpenAttachment when open fails\")",
                    "    func throwsIfServiceCannotOpenAttachment() {",
                    "        service.isSuccessful = false",
                    "        #expect(throws: AttachmentOpeningError.unableToOpenAttachment) {",
                    "            try attachmentOpener.openAttachment(file: location, with: service)",
                    "        }",
                    "    }",
                    "}"
                  ],
                  "syntax": "swift",
                  "type": "codeListing"
                }
              ],
              "title": "Swift Testing"
            },
            {
              "content": [
                {
                  "code": [
                    "class AttachmentOpenerTests: XCTestCase {",
                    "    var service: StubService! = nil",
                    "    var attachmentOpener: AttachmentOpener! = nil",
                    "    let location = URL(fileURLWithPath: \"/tmp/a_file.txt\")",
                    "",
                    "    override func setUp() {",
                    "        service = StubService()",
                    "        attachmentOpener = AttachmentOpener()",
                    "    }",
                    "",
                    "    override func tearDown() {",
                    "        service = nil",
                    "        attachmentOpener = nil",
                    "    }",
                    "",
                    "    func testServiceCanOpenAttachment() {",
                    "        service.isSuccessful = true",
                    "        XCTAssertNoThrow(try attachmentOpener.openAttachment(file: location, with: service))",
                    "    }",
                    "",
                    "",
                    "    func testThrowIfServiceCannotOpenAttachment() {",
                    "        service.isSuccessful = false",
                    "        XCTAssertThrowsError(try attachmentOpener.openAttachment(file: location, with: service))",
                    "    }",
                    "}"
                  ],
                  "syntax": "objc",
                  "type": "codeListing"
                }
              ],
              "title": "XCTest"
            }
          ],
          "type": "tabNavigator"
        },
        {
          "anchor": "Replace-named-type-with-metatype-value",
          "level": 3,
          "text": "Replace named type with metatype value",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "When one class in your app creates and uses instances of another class, and the created",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "objects introduce testing difficulties, it can be hard to test the class where they’re",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "created. Parameterize the type of the created object and use a required initializer",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "to create an instance. Examples of this difficult testing situation include a controller",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "that creates a new document on the filesystem in response to a person’s action, or a",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "method that interprets JSON received from a web service and creates new Core Data",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "managed objects that represent the received data.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "In each of these cases, because the objects are created by the code you want to test,",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "you can’t pass in a different object as a parameter to the method. The object doesn’t",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "exist until it’s created by your code, at which point it’s of the type that has the",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "untestable behavior.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "The listing below shows a ",
              "type": "text"
            },
            {
              "code": "DocumentLoader",
              "type": "codeVoice"
            },
            {
              "text": " class that creates and loads a ",
              "type": "text"
            },
            {
              "code": "Document",
              "type": "codeVoice"
            },
            {
              "text": ", for example, in response to a UI action.",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "The document object it creates reads and writes data to the file system, so its behavior",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "isn’t easy to control in a unit test.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "enum DocumentError : Error {",
            "    case cannotLoadContent",
            "    case cannotSaveContent",
            "}",
            "",
            "class Document {",
            "    private var location: URL",
            "    private var titleContent: String?",
            "    var title : String {",
            "        get {",
            "            return titleContent ?? \"Untitled\"",
            "        }",
            "        set {",
            "            titleContent = newValue",
            "        }",
            "    }",
            "",
            "    required init(fileURL: URL) {",
            "        location = fileURL",
            "    }",
            "    ",
            "    func load() throws {",
            "        do {",
            "            let myString = try String(contentsOf: location, encoding: .utf8)",
            "        }",
            "        catch {",
            "            throw DocumentError.cannotLoadContent",
            "        }",
            "    }",
            "    ",
            "    func save() throws {",
            "        do {",
            "            try titleContent?.write(to: location, atomically: true, encoding: .utf8)",
            "        }",
            "        catch {",
            "            throw DocumentError.cannotSaveContent",
            "        }",
            "    }",
            "}",
            "",
            "class DocumentLoader {",
            "    func loadDocument(at location: URL) -> Bool {",
            "        do {",
            "            var document = Document(fileURL: location)",
            "            try document.load()",
            "            // Do something with the document, for example, present it in the app's UI.",
            "            return true",
            "        } catch {",
            "            return false",
            "        }",
            "    }",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "To remove the coupling between the code you’re trying to test and the objects it",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "creates, define a variable on the class under test that represents the ",
              "type": "text"
            },
            {
              "inlineContent": [
                {
                  "text": "type",
                  "type": "text"
                }
              ],
              "type": "emphasis"
            },
            {
              "text": " of",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "object it should construct. Such a variable is called a ",
              "type": "text"
            },
            {
              "inlineContent": [
                {
                  "text": "metatype value",
                  "type": "text"
                }
              ],
              "type": "emphasis"
            },
            {
              "text": ". Set the",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "default value to the type the class already uses. You’ll need to ensure that the",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "initializer used to construct instances is marked ",
              "type": "text"
            },
            {
              "code": "required",
              "type": "codeVoice"
            },
            {
              "text": ". This listing shows",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "the document browser view controller delegate with that variable introduced. The",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "delegate creates documents with the type defined by the metatype value.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "class DocumentLoader {",
            "    var DocumentClass = Document.self",
            "",
            "    func loadDocument(at location: URL) -> Bool {",
            "        do {",
            "            var document = DocumentClass.init(fileURL: location)",
            "            try document.load()",
            "            // Do something with the document, for example, present it in the app's UI.",
            "            return true",
            "        } catch {",
            "            return false",
            "        }",
            "    }",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "Set a different value for the metatype in tests, so your code constructs an object",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "that doesn’t have the same untestable behavior. In tests, create a “sample” version",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "of the document class: a class with the same interface, but which doesn’t implement",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "the behavior that makes it hard to test. In this case, a sample document class should",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "not interact with the file system.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "class SampleDocument : Document {",
            "    static var loadsSuccessfully : Bool = true",
            "    static var savesSuccessfully : Bool = true",
            "    ",
            "    override func load() throws {",
            "        guard SampleDocument.loadsSuccessfully else {",
            "            throw DocumentError.cannotLoadContent",
            "        }",
            "    }",
            "    ",
            "    override func save() throws {",
            "        guard SampleDocument.savesSuccessfully else {",
            "            throw DocumentError.cannotSaveContent",
            "        }",
            "    }",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "Replace the document type with the sample type in your test case’s ",
              "type": "text"
            },
            {
              "code": "setUp()",
              "type": "codeVoice"
            },
            {
              "text": " method,",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "so the document loader you test creates instances of the stub document type. Sample documents",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "behave deterministically in the tests.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "tabs": [
            {
              "content": [
                {
                  "code": [
                    "@Suite final class DocumentLoaderTests {",
                    "    let loader = DocumentLoader()",
                    "",
                    "    init() {",
                    "        loader.DocumentClass = SampleDocument.self",
                    "    }",
                    "",
                    "    @Test @MainActor func documentLoaderReturnsFalseWhenDocumentCannotLoad() {",
                    "        SampleDocument.loadsSuccessfully = false",
                    "        #expect(loader.loadDocument(at: URL(filePath: \"/Users/example/Documents/document.txt\")) == false)",
                    "    }",
                    "",
                    "    @Test @MainActor func documentLoaderReturnsTrueWhenDocumentLoads() {",
                    "        SampleDocument.loadsSuccessfully = true",
                    "        #expect(loader.loadDocument(at: URL(filePath: \"/Users/example/Documents/document.txt\")) == true)",
                    "    }",
                    "}"
                  ],
                  "syntax": "swift",
                  "type": "codeListing"
                },
                {
                  "content": [
                    {
                      "inlineContent": [
                        {
                          "text": "",
                          "type": "text"
                        },
                        {
                          "text": " ",
                          "type": "text"
                        },
                        {
                          "text": "As these tests rely on the shared ",
                          "type": "text"
                        },
                        {
                          "code": "SampleDocument.loadsSuccessfully",
                          "type": "codeVoice"
                        },
                        {
                          "text": " state, they can’t run concurrently.",
                          "type": "text"
                        },
                        {
                          "text": " ",
                          "type": "text"
                        },
                        {
                          "text": "The tests are annotated with ",
                          "type": "text"
                        },
                        {
                          "code": "@MainActor",
                          "type": "codeVoice"
                        },
                        {
                          "text": " to ensure they run in series.",
                          "type": "text"
                        }
                      ],
                      "type": "paragraph"
                    }
                  ],
                  "name": "Note",
                  "style": "note",
                  "type": "aside"
                }
              ],
              "title": "Swift Testing"
            },
            {
              "content": [
                {
                  "code": [
                    "class DocumentLoaderTests: XCTestCase {",
                    "    var loader: DocumentLoader! = nil",
                    "",
                    "    override func setUp() {",
                    "        loader = DocumentLoader()",
                    "        loader.DocumentClass = SampleDocument.self",
                    "    }",
                    "",
                    "    override func tearDown() {}",
                    "",
                    "    func testDocumentLoaderReturnsFalseWhenDocumentCannotLoad() {",
                    "        SampleDocument.loadsSuccessfully = false",
                    "        XCTAssertFalse(loader.loadDocument(at: URL(filePath: \"/Users/example/Documents/document.txt\")))",
                    "    }",
                    "",
                    "    func testDocumentLoaderReturnsTrueWhenDocumentLoads() {",
                    "        SampleDocument.loadsSuccessfully = true",
                    "        XCTAssertTrue(loader.loadDocument(at: URL(filePath: \"/Users/example/Documents/document.txt\")))",
                    "    }",
                    "}"
                  ],
                  "syntax": "swift",
                  "type": "codeListing"
                }
              ],
              "title": "XCTest"
            }
          ],
          "type": "tabNavigator"
        },
        {
          "anchor": "Subclass-and-override-untestable-methods",
          "level": 3,
          "text": "Subclass and override untestable methods",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "When a class combines custom logic with interactions or behavior that make the class",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "hard to test, introduce a subclass that overrides some of the class’s methods to",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "make the others easier to test. It’s common to design classes that contain both app-specific",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "logic, and interactions with the environment or frameworks that render behavior difficult",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "to control in tests. A common example is a ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.documentation/documentation/UIKit/UIViewController",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "subclass, which has app-specific code in its action methods and also loads views",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "or presents other view controllers.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "Introducing tests for the custom app logic is desirable, to ensure that this logic",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "works as expected and to protect against regressions. The complexity of controlling",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "or working around the interactions between the class and the environment make testing",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "the logic difficult.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "As an example, the following account object provides a method to calculate someone’s birthday.",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "It does the calculation by finding the number of years between the account’s recorded date of birth and today’s date.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "import Foundation",
            "",
            "enum AccountError : Error {",
            "    case cannotCalculateAge",
            "}",
            "",
            "class Account {",
            "    let name: String",
            "    let email: String",
            "    let userId: String",
            "    let dateOfBirth: Date",
            "    ",
            "    init(name: String, email: String, userId: String, dateOfBirth: Date) {",
            "        self.name = name",
            "        self.email = email",
            "        self.userId = userId",
            "        self.dateOfBirth = dateOfBirth",
            "    }",
            "    ",
            "    var now : Date {",
            "        get {",
            "            return Date()",
            "        }",
            "    }",
            "    ",
            "    func age() throws -> Int {",
            "        let calendar = Calendar.current",
            "        let birthday = calendar.startOfDay(for: dateOfBirth)",
            "        let today = calendar.startOfDay(for: now)",
            "        guard let years =  calendar.dateComponents([.year], from: birthday, to: today).year else {",
            "            throw AccountError.cannotCalculateAge",
            "        }",
            "        return years",
            "    }",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "Testing this object’s behavior is difficult because the ",
              "type": "text"
            },
            {
              "code": "now",
              "type": "codeVoice"
            },
            {
              "text": " field gets its value from the system’s clock.",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "If the clock isn’t set correctly then the test might fail, and as time passes the value returned from ",
              "type": "text"
            },
            {
              "code": "now",
              "type": "codeVoice"
            },
            {
              "text": " changes so a test’s expectation of the computed age would become out of date.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "To overcome this complexity, subclass the ",
              "type": "text"
            },
            {
              "code": "Account",
              "type": "codeVoice"
            },
            {
              "text": " and “stub out” methods",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "that produce complex, untestable interactions, by overriding them with simpler methods.",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "Use the subclass in your tests to verify the behavior of the custom logic, which",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "you don’t override. You may also need to introduce a metatype value, if the code",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "under test creates an instance of the target type.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "The following listing introduces a subclass, ",
              "type": "text"
            },
            {
              "code": "StubAccount",
              "type": "codeVoice"
            },
            {
              "text": ", which doesn’t rely on the system’s clock.",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "Instead, it uses a fixed date that’s configured by the caller. Tests using this subclass provide fixed values for both the account’s date of birth and the date that represents the current date, to ensure that the calculation the ",
              "type": "text"
            },
            {
              "code": "Account",
              "type": "codeVoice"
            },
            {
              "text": " object performs is correct.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "class StubAccount : Account {",
            "    private var overrideNow : Date",
            "    ",
            "    init(name: String, email: String, userId: String, dateOfBirth: Date, overrideNow: Date) {",
            "        self.overrideNow = overrideNow",
            "        super.init(name: name, email: email, userId: userId, dateOfBirth: dateOfBirth)",
            "    }",
            "    ",
            "    override var now : Date {",
            "        overrideNow",
            "    }",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "In testing types, create instances of ",
              "type": "text"
            },
            {
              "code": "StubAccount",
              "type": "codeVoice"
            },
            {
              "text": " and test the date-calculation logic inherited from ",
              "type": "text"
            },
            {
              "code": "Account",
              "type": "codeVoice"
            },
            {
              "text": ". Because ",
              "type": "text"
            },
            {
              "code": "StubAccount",
              "type": "codeVoice"
            },
            {
              "text": " lets the test code control the date that represents the current date, the test behavior doesn’t depend on the system’s clock.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "tabs": [
            {
              "content": [
                {
                  "code": [
                    "@Suite struct AccountTests {",
                    "    @Test func accountCalculatesAgeCorrectly() throws {",
                    "        let dateOfBirth = Calendar.current.date(from: DateComponents(",
                    "            timeZone: TimeZone(identifier: \"Europe/London\"),",
                    "            year: 1970,",
                    "            month: 1,",
                    "            day: 1",
                    "        ))!",
                    "        let fixedDateForToday = Calendar.current.date(from: DateComponents(",
                    "            timeZone: TimeZone(identifier: \"Europe/London\"),",
                    "            year: 2024,",
                    "            month: 12,",
                    "            day: 31",
                    "        ))!",
                    "        let account = StubAccount(name: \"Example Account\", email: \"account@example.com\", userId: \"example\", dateOfBirth: dateOfBirth, overrideNow: fixedDateForToday)",
                    "        #expect(try account.age() == 54)",
                    "    }",
                    "}"
                  ],
                  "syntax": "swift",
                  "type": "codeListing"
                }
              ],
              "title": "Swift Testing"
            },
            {
              "content": [
                {
                  "code": [
                    "class AccountTests : XCTestCase {",
                    "    private var account: StubAccount! = nil",
                    "",
                    "    override func setUp() {",
                    "        let dateOfBirth = Calendar.current.date(from: DateComponents(",
                    "            timeZone: TimeZone(identifier: \"Europe/London\"),",
                    "            year: 1970,",
                    "            month: 1,",
                    "            day: 1",
                    "        ))!",
                    "        let fixedDateForToday = Calendar.current.date(from: DateComponents(",
                    "            timeZone: TimeZone(identifier: \"Europe/London\"),",
                    "            year: 2024,",
                    "            month: 12,",
                    "            day: 31",
                    "        ))!",
                    "        account = StubAccount(name: \"Example Account\", email: \"account@example.com\", userId: \"example\", dateOfBirth: dateOfBirth, overrideNow: fixedDateForToday)",
                    "    }",
                    "",
                    "    override func tearDown() { }",
                    "",
                    "    func testAccountCalculatesAgeCorrectly() throws {",
                    "        XCTAssertEqual(try account.age(), 54)",
                    "    }",
                    "}"
                  ],
                  "syntax": "swift",
                  "type": "codeListing"
                }
              ],
              "title": "XCTest"
            }
          ],
          "type": "tabNavigator"
        },
        {
          "inlineContent": [
            {
              "text": "Sometimes this pattern can help you test existing classes that combine",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "multiple responsibilities, but only if those classes and the methods aren’t marked",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "as ",
              "type": "text"
            },
            {
              "code": "final",
              "type": "codeVoice"
            },
            {
              "text": " and it isn’t a good practice to follow in designing testable code from",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "scratch. Separate code that handles different concerns into different classes, for example:",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "items": [
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "text": "Controller classes that implement your app’s custom behavior.",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            },
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "text": "View controllers that manage your view hierarchy and respond to UI actions.",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            },
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "text": "View models that prepare and update data you present in your app’s views.",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            }
          ],
          "type": "unorderedList"
        },
        {
          "inlineContent": [
            {
              "text": "Add UI tests to verify the behavior of the real class in an end-to-end workflow",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "covering the logic you stubbed out in the unit tests.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "Subclassing and overriding untestable methods is the first",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "step in redesigning existing code so app logic and integration with frameworks or",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "external data are separated. Dividing the code this way makes it easier to understand",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "which parts of your project implement the app’s features and which integrate with",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "the rest of the system, and it also reduces the chance of introducing logic bugs",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "when you change your code to take advantage of new APIs or adopt different technologies.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "anchor": "Inject-a-singleton",
          "level": 3,
          "text": "Inject a singleton",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "If your code uses a singleton object to gain access to globally-available state or",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "behavior, turn the singleton into a parameter that you can replace to support isolation",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "for testing. Singleton use can be spread throughout a codebase, which makes it hard",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "to know the singleton’s state when it’s used by the component you’re trying to test.",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "Running tests in different orders may produce different outcomes.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "content": [
            {
              "inlineContent": [
                {
                  "text": "Commonly-used singletons, including ",
                  "type": "text"
                },
                {
                  "identifier": "doc://com.apple.documentation/documentation/AppKit/NSApplication",
                  "isActive": true,
                  "type": "reference"
                },
                {
                  "text": " ",
                  "type": "text"
                },
                {
                  "text": "and the default ",
                  "type": "text"
                },
                {
                  "identifier": "doc://com.apple.documentation/documentation/foundation/filemanager",
                  "isActive": true,
                  "type": "reference"
                },
                {
                  "text": ",",
                  "type": "text"
                },
                {
                  "text": " ",
                  "type": "text"
                },
                {
                  "text": "have behavior that’s dependent on external state. Components that use these singletons",
                  "type": "text"
                },
                {
                  "text": " ",
                  "type": "text"
                },
                {
                  "text": "directly introduce more complications for reliable testing.",
                  "type": "text"
                }
              ],
              "type": "paragraph"
            }
          ],
          "name": "Note",
          "style": "note",
          "type": "aside"
        },
        {
          "inlineContent": [
            {
              "text": "In this example, a ",
              "type": "text"
            },
            {
              "code": "LoginHandler",
              "type": "codeVoice"
            },
            {
              "text": " object participates in authenticating someone to a network service.",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "Part of its capability is retrieving a username that the app previously used for the service, which it gets from the standard user defaults object:",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "class LoginHandler {",
            "    ",
            "    var previousUsername: String? {",
            "        get {",
            "            UserDefaults.standard.string(forKey: \"ExampleAccountUsername\")",
            "        }",
            "    }",
            "    ",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "identifier": "doc://com.apple.documentation/documentation/foundation/userdefaults",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " relies on shared",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "state that’s stored in the file system and might be modified by other code in the app",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "or by someone editing files on their Mac.",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "Replace direct access to the singleton object with a parameter or property that can",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "be controlled from outside the component under test. In the app, continue to use",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "the singleton as the collaborator for the component. In tests, supply an alternative",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "object that’s easier to control.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "The following listing shows the result of applying this change to the ",
              "type": "text"
            },
            {
              "code": "LoginHandler",
              "type": "codeVoice"
            },
            {
              "text": " class",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "listed above. The login handler gets the stored username from its ",
              "type": "text"
            },
            {
              "code": "storage",
              "type": "codeVoice"
            },
            {
              "text": " object,",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "which defaults to the user defaults singleton. An extension conforms ",
              "type": "text"
            },
            {
              "code": "UserDefaults",
              "type": "codeVoice"
            },
            {
              "text": " to the",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "code": "LoginStorage",
              "type": "codeVoice"
            },
            {
              "text": " protocol, so that tests can supply alternative implementations of the protocol.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "protocol LoginStorage {",
            "    func string(forKey: String) -> String?",
            "}",
            "",
            "extension UserDefaults : LoginStorage { }",
            "",
            "class LoginHandler {",
            "    private var storage: LoginStorage",
            "    ",
            "    init(storage: LoginStorage = UserDefaults.standard) {",
            "        self.storage = storage",
            "    }",
            "    ",
            "    var previousUsername: String? {",
            "        get {",
            "            storage.string(forKey: \"ExampleAccountUsername\")",
            "        }",
            "    }",
            "    ",
            "}"
          ],
          "syntax": "swift",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "In a test case you can substitute a different storage object, which isn’t used",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "elsewhere in the test suite or the app, and therefore is isolated from the behavior",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "of other tests and modules.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "tabs": [
            {
              "content": [
                {
                  "code": [
                    "struct StubLoginStorage : LoginStorage {",
                    "    let value: String?",
                    "",
                    "    init(value: String?) {",
                    "        self.value = value",
                    "    }",
                    "",
                    "    func string(forKey: String) -> String? {",
                    "        value",
                    "    }",
                    "}",
                    "",
                    "@Suite struct LoginHandlerTests {",
                    "    let handler: LoginHandler = LoginHandler(storage: StubLoginStorage(value: \"example-username\"))",
                    "",
                    "    @Test func handlerGetsUsernameFromStorage() {",
                    "        #expect(handler.previousUsername == \"example-username\")",
                    "    }",
                    "}"
                  ],
                  "syntax": "swift",
                  "type": "codeListing"
                }
              ],
              "title": "Swift Testing"
            },
            {
              "content": [
                {
                  "code": [
                    "struct StubLoginStorage : LoginStorage {",
                    "    let value: String?",
                    "",
                    "    init(value: String?) {",
                    "        self.value = value",
                    "    }",
                    "",
                    "    func string(forKey: String) -> String? {",
                    "        value",
                    "    }",
                    "}",
                    "",
                    "class XCLoginHandlerTests : XCTestCase {",
                    "    var handler: LoginHandler! = nil",
                    "",
                    "    override func setUp() {",
                    "        handler = LoginHandler(storage: StubLoginStorage(value: \"example-username\"))",
                    "    }",
                    "",
                    "    func testHandlerGetsUsernameFromStorage() {",
                    "        XCTAssertEqual(handler.previousUsername, \"example-username\")",
                    "    }",
                    "}"
                  ],
                  "syntax": "swift",
                  "type": "codeListing"
                }
              ],
              "title": "XCTest"
            }
          ],
          "type": "tabNavigator"
        },
        {
          "inlineContent": [
            {
              "text": "You may need to combine this change with those described in the article sections",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "(",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.Xcode/documentation/Xcode/updating-your-existing-codebase-to-accommodate-unit-tests#Replace-a-concrete-type-with-a-protocol",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " and ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.Xcode/documentation/Xcode/updating-your-existing-codebase-to-accommodate-unit-tests#Subclass-and-override-untestable-methods",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": ")",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "to create the alternative object you use in the test in place of the singleton. You’ll",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "need to do this where the singleton supplies behavior that’s difficult to control",
              "type": "text"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "in a test, like ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.documentation/documentation/foundation/filemanager",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " ",
              "type": "text"
            },
            {
              "text": "or ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.documentation/documentation/AppKit/NSApplication",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": ".",
              "type": "text"
            }
          ],
          "type": "paragraph"
        }
      ],
      "kind": "content"
    }
  ],
  "references": {
    "Xcode-PageImage-card.png": {
      "alt": "The Xcode logo on a blue gradient background.",
      "identifier": "Xcode-PageImage-card.png",
      "type": "image",
      "variants": [
        {
          "traits": [
            "2x",
            "light"
          ],
          "url": "https://docs-assets.developer.apple.com/published/cc63eacd8f7f660388b46204d1d9bbcb/Xcode-PageImage-card@2x.png"
        },
        {
          "traits": [
            "2x",
            "dark"
          ],
          "url": "https://docs-assets.developer.apple.com/published/62dba87d5f60ec96eb48882c9dff86d8/Xcode-PageImage-card~dark@2x.png"
        }
      ]
    },
    "adding-tests-pageimage-card.png": {
      "alt": "Artistic rendering of an iPhone laying face up next to a green checkmark.",
      "identifier": "adding-tests-pageimage-card.png",
      "type": "image",
      "variants": [
        {
          "traits": [
            "2x",
            "light"
          ],
          "url": "https://docs-assets.developer.apple.com/published/74aabcd2e16d1e9023a4aa6b55fec34b/adding-tests-pageimage-card@2x.png"
        },
        {
          "traits": [
            "2x",
            "dark"
          ],
          "url": "https://docs-assets.developer.apple.com/published/7d44d4f36b4bf35927e88c40edaf34ab/adding-tests-pageimage-card~dark@2x.png"
        }
      ]
    },
    "doc://com.apple.Xcode/documentation/Xcode": {
      "abstract": [
        {
          "text": "Build, test, and submit your app with Apple’s integrated development environment.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.Xcode/documentation/Xcode",
      "images": [
        {
          "identifier": "Xcode-PageImage-card.png",
          "type": "card"
        }
      ],
      "kind": "article",
      "role": "collection",
      "title": "Xcode",
      "type": "topic",
      "url": "/documentation/xcode"
    },
    "doc://com.apple.Xcode/documentation/Xcode/adding-tests-to-your-xcode-project": {
      "abstract": [
        {
          "text": "Include test targets that build code to test the logic in your functions, check for integration issues, automate UI workflows, and measure performance.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.Xcode/documentation/Xcode/adding-tests-to-your-xcode-project",
      "images": [
        {
          "identifier": "adding-tests-pageimage-card.png",
          "type": "card"
        }
      ],
      "kind": "article",
      "role": "article",
      "title": "Adding tests to your Xcode project",
      "type": "topic",
      "url": "/documentation/xcode/adding-tests-to-your-xcode-project"
    },
    "doc://com.apple.Xcode/documentation/Xcode/determining-how-much-code-your-tests-cover": {
      "abstract": [
        {
          "text": "Use code coverage to focus new test development on areas that lack adequate testing.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.Xcode/documentation/Xcode/determining-how-much-code-your-tests-cover",
      "kind": "article",
      "role": "article",
      "title": "Determining how much code your tests cover",
      "type": "topic",
      "url": "/documentation/xcode/determining-how-much-code-your-tests-cover"
    },
    "doc://com.apple.Xcode/documentation/Xcode/organizing-tests-to-improve-feedback": {
      "abstract": [
        {
          "text": "Control the information you receive from your tests at different stages in the software engineering process by creating and configuring test plans.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.Xcode/documentation/Xcode/organizing-tests-to-improve-feedback",
      "kind": "article",
      "role": "article",
      "title": "Improving code assessment by organizing tests into test plans",
      "type": "topic",
      "url": "/documentation/xcode/organizing-tests-to-improve-feedback"
    },
    "doc://com.apple.Xcode/documentation/Xcode/testing": {
      "abstract": [
        {
          "text": "Develop and run tests to detect logic failures, UI problems, and performance regressions.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.Xcode/documentation/Xcode/testing",
      "kind": "article",
      "role": "collectionGroup",
      "title": "Testing",
      "type": "topic",
      "url": "/documentation/xcode/testing"
    },
    "doc://com.apple.Xcode/documentation/Xcode/updating-your-existing-codebase-to-accommodate-unit-tests#Replace-a-concrete-type-with-a-protocol": {
      "abstract": [],
      "identifier": "doc://com.apple.Xcode/documentation/Xcode/updating-your-existing-codebase-to-accommodate-unit-tests#Replace-a-concrete-type-with-a-protocol",
      "kind": "section",
      "title": "Replace a concrete type with a protocol",
      "type": "topic",
      "url": "/documentation/xcode/updating-your-existing-codebase-to-accommodate-unit-tests#Replace-a-concrete-type-with-a-protocol"
    },
    "doc://com.apple.Xcode/documentation/Xcode/updating-your-existing-codebase-to-accommodate-unit-tests#Subclass-and-override-untestable-methods": {
      "abstract": [],
      "identifier": "doc://com.apple.Xcode/documentation/Xcode/updating-your-existing-codebase-to-accommodate-unit-tests#Subclass-and-override-untestable-methods",
      "kind": "section",
      "title": "Subclass and override untestable methods",
      "type": "topic",
      "url": "/documentation/xcode/updating-your-existing-codebase-to-accommodate-unit-tests#Subclass-and-override-untestable-methods"
    },
    "doc://com.apple.documentation/documentation/AppKit/NSApplication": {
      "abstract": [
        {
          "text": "An object that manages an app’s main event loop and resources used by all of that app’s objects.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "attribute",
          "text": "@"
        },
        {
          "kind": "attribute",
          "preciseIdentifier": "s:ScM",
          "text": "MainActor"
        },
        {
          "kind": "text",
          "text": " "
        },
        {
          "kind": "keyword",
          "text": "class"
        },
        {
          "kind": "text",
          "text": " "
        },
        {
          "kind": "identifier",
          "text": "NSApplication"
        }
      ],
      "identifier": "doc://com.apple.documentation/documentation/AppKit/NSApplication",
      "kind": "symbol",
      "role": "symbol",
      "title": "NSApplication",
      "type": "topic",
      "url": "/documentation/AppKit/NSApplication"
    },
    "doc://com.apple.documentation/documentation/UIKit/UIViewController": {
      "abstract": [
        {
          "text": "An object that manages a view hierarchy for your UIKit app.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "attribute",
          "text": "@"
        },
        {
          "kind": "attribute",
          "preciseIdentifier": "s:ScM",
          "text": "MainActor"
        },
        {
          "kind": "text",
          "text": " "
        },
        {
          "kind": "keyword",
          "text": "class"
        },
        {
          "kind": "text",
          "text": " "
        },
        {
          "kind": "identifier",
          "text": "UIViewController"
        }
      ],
      "identifier": "doc://com.apple.documentation/documentation/UIKit/UIViewController",
      "kind": "symbol",
      "role": "symbol",
      "title": "UIViewController",
      "type": "topic",
      "url": "/documentation/UIKit/UIViewController"
    },
    "doc://com.apple.documentation/documentation/foundation/filemanager": {
      "abstract": [
        {
          "text": "A convenient interface to the contents of the file system, and the primary means of interacting with it.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "text",
          "text": "class "
        },
        {
          "kind": "identifier",
          "text": "FileManager"
        }
      ],
      "identifier": "doc://com.apple.documentation/documentation/foundation/filemanager",
      "kind": "symbol",
      "role": "symbol",
      "title": "FileManager",
      "type": "topic",
      "url": "/documentation/foundation/filemanager"
    },
    "doc://com.apple.documentation/documentation/foundation/userdefaults": {
      "abstract": [
        {
          "text": "An interface to the user’s defaults database, where you store key-value pairs persistently across launches of your app.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "text",
          "text": "class "
        },
        {
          "kind": "identifier",
          "text": "UserDefaults"
        }
      ],
      "identifier": "doc://com.apple.documentation/documentation/foundation/userdefaults",
      "kind": "symbol",
      "role": "symbol",
      "title": "UserDefaults",
      "type": "topic",
      "url": "/documentation/foundation/userdefaults"
    },
    "doc://com.apple.documentation/documentation/technologies": {
      "abstract": [
        {
          "text": "",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.documentation/documentation/technologies",
      "kind": "technologies",
      "role": "overview",
      "title": "Technologies",
      "type": "topic",
      "url": "/documentation/technologies"
    }
  },
  "schemaVersion": {
    "major": 0,
    "minor": 3,
    "patch": 0
  },
  "sections": [],
  "seeAlsoSections": [
    {
      "anchor": "Test-development",
      "generated": true,
      "identifiers": [
        "doc://com.apple.Xcode/documentation/Xcode/adding-tests-to-your-xcode-project",
        "doc://com.apple.Xcode/documentation/Xcode/determining-how-much-code-your-tests-cover",
        "doc://com.apple.Xcode/documentation/Xcode/organizing-tests-to-improve-feedback"
      ],
      "title": "Test development"
    }
  ],
  "variantOverrides": [
    {
      "patch": [
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.documentation~1documentation~1foundation~1filemanager/title",
          "value": "NSFileManager"
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.documentation~1documentation~1UIKit~1UIViewController/fragments",
          "value": [
            {
              "kind": "keyword",
              "text": "@interface"
            },
            {
              "kind": "text",
              "text": " "
            },
            {
              "kind": "identifier",
              "text": "UIViewController"
            },
            {
              "kind": "text",
              "text": " : "
            },
            {
              "kind": "typeIdentifier",
              "preciseIdentifier": "c:objc(cs)UIResponder",
              "text": "UIResponder"
            }
          ]
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.documentation~1documentation~1AppKit~1NSApplication/fragments",
          "value": [
            {
              "kind": "keyword",
              "text": "@interface"
            },
            {
              "kind": "text",
              "text": " "
            },
            {
              "kind": "identifier",
              "text": "NSApplication"
            },
            {
              "kind": "text",
              "text": " : "
            },
            {
              "kind": "typeIdentifier",
              "preciseIdentifier": "c:objc(cs)NSResponder",
              "text": "NSResponder"
            }
          ]
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.documentation~1documentation~1foundation~1userdefaults/title",
          "value": "NSUserDefaults"
        }
      ],
      "traits": [
        {
          "interfaceLanguage": "occ"
        }
      ]
    }
  ]
}
