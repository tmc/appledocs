{
  "abstract": [
    {
      "text": "Switch dynamically between multiple GPUs to efficiently render to a display.",
      "type": "text"
    }
  ],
  "hierarchy": {
    "paths": [
      [
        "doc://com.apple.documentation/documentation/technologies",
        "doc://com.apple.metal/documentation/Metal",
        "doc://com.apple.metal/documentation/Metal/metal-sample-code-library"
      ],
      [
        "doc://com.apple.documentation/documentation/technologies",
        "doc://com.apple.metal/documentation/Metal",
        "doc://com.apple.metal/documentation/Metal/gpu-devices-and-work-submission",
        "doc://com.apple.metal/documentation/Metal/multi-gpu-systems"
      ]
    ]
  },
  "identifier": {
    "interfaceLanguage": "swift",
    "url": "doc://com.apple.metal/documentation/Metal/selecting-device-objects-for-graphics-rendering"
  },
  "kind": "article",
  "legalNotices": {
    "copyright": "Copyright &copy; 2025 Apple Inc. All rights reserved.",
    "privacyPolicy": "https://www.apple.com/privacy/privacy-policy",
    "termsOfUse": "https://www.apple.com/legal/internet-services/terms/site.html"
  },
  "metadata": {
    "modules": [
      {
        "name": "Metal"
      }
    ],
    "platforms": [
      {
        "beta": false,
        "introducedAt": "10.13",
        "name": "macOS"
      },
      {
        "beta": false,
        "introducedAt": "12.4",
        "name": "Xcode"
      }
    ],
    "role": "sampleCode",
    "roleHeading": "Sample Code",
    "title": "Selecting Device Objects for Graphics Rendering"
  },
  "primaryContentSections": [
    {
      "content": [
        {
          "anchor": "Overview",
          "level": 2,
          "text": "Overview",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "macOS supports systems that have multiple GPUs and displays. An example is a MacBook Pro with a low-power integrated GPU, a high-performance discrete GPU, a powerful external GPU, and additional displays. Metal apps must carefully select a GPU that maximizes efficiency and performance for a given display. They should also gracefully respond to any GPU or display changes, such as when the user disconnects an external GPU or moves a window between displays.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "anchor": "Getting-Started",
          "level": 3,
          "text": "Getting Started",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "Not all Mac computers have both an integrated GPU and a discrete GPU. To check the GPUs in your Mac, choose Apple menu > About this Mac, press the System Report button, and select Graphics/Displays on the left. The GPUs are listed under Video Card. MacBook Pro computers with two GPUs have an Automatic Graphics Switching option, turned on by default, that allows the system to automatically switch between the two GPUs. To toggle the Automatic Graphics Switching state, choose Apple menu > System Preferences and click Energy Saver. The Automatic Graphics Switching checkbox is shown at the top.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "Optionally, you may connect an external GPU to your Mac via Thunderbolt 3, and you may also connect an external display to your external GPU. For this system setup, your Mac must be running macOS 10.13.4 or later. Connecting an external GPU allows the sample to run the code described in Handle External GPU Notifications.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "The sample provides these interactive UI controls:",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "items": [
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "inlineContent": [
                        {
                          "text": "Device Selection Mode.",
                          "type": "text"
                        }
                      ],
                      "type": "strong"
                    },
                    {
                      "text": " Allow the sample to automatically select the best device for the display, or indicate that you want to manually select a device.",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            },
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "inlineContent": [
                        {
                          "text": "Manual Device Selection.",
                          "type": "text"
                        }
                      ],
                      "type": "strong"
                    },
                    {
                      "text": " Manually select a device from a list of available devices.",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            }
          ],
          "type": "unorderedList"
        },
        {
          "inlineContent": [
            {
              "text": "Furthermore, the Device Driving Display label indicates which device is currently driving the display.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "anchor": "Drawables-Displays-and-GPUs",
          "level": 3,
          "text": "Drawables, Displays, and GPUs",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "Each view in your app is shown on a single display, and each display is driven by a single GPU. To show graphics content in your view, the view’s display presents a rendered drawable from the display’s driving GPU.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "If your app renders with a GPU that isn’t driving your view’s display, the system must copy the drawable from the rendering GPU to the displaying GPU before presenting it. This transfer can be expensive because the bandwidth between GPUs is limited by the bus that connects them. This expense is more severe with external GPUs because their Thunderbolt 3 bus has much less bandwidth than an internal PCI Express bus.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "The fastest path to present a drawable is to render that drawable with the GPU that drives your view’s display. An example is a MacBook Pro with a discrete GPU and an integrated GPU, where the integrated GPU can drive the MacBook Pro’s display under certain conditions (caused by thermal state, battery life, or app needs).",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "identifier": "FastestDrawablePath_BuiltIn",
              "type": "image"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "Another example is a Mac connected to an external GPU, where the external GPU drives an external display.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "identifier": "FastestDrawablePath_External",
              "type": "image"
            }
          ],
          "type": "paragraph"
        },
        {
          "anchor": "Transition-Smoothly-Between-Devices",
          "level": 3,
          "text": "Transition Smoothly Between Devices",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "The sample’s view controller manages all Metal devices, with each device representing a different GPU. When the sample runs the ",
              "type": "text"
            },
            {
              "code": "viewDidLoad",
              "type": "codeVoice"
            },
            {
              "text": " method, the view controller initializes a new ",
              "type": "text"
            },
            {
              "code": "AAPLRenderer",
              "type": "codeVoice"
            },
            {
              "text": " for each device available to the system. The sample uses only one device at a time, but it initializes a renderer for each device in order to preload and mirror the app’s Metal resources across all devices. Therefore, when the app switches between GPUs at runtime, the sample  transitions smoothly between devices because equivalent resources are already available and loaded on each device. This preloading and mirroring strategy avoids significant delays that would otherwise exist if the sample needed to load resources at the time of the switch.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "content": [
            {
              "inlineContent": [
                {
                  "text": "Preloading and mirroring resources allows you to transition smoothly between devices, but it also increases your app’s total memory usage. You must carefully determine which resources should be preloaded and mirrored, and which resources should instead be loaded only when your app switches between devices.",
                  "type": "text"
                }
              ],
              "type": "paragraph"
            }
          ],
          "name": "Note",
          "style": "note",
          "type": "aside"
        },
        {
          "anchor": "Set-the-Optimal-Device-for-the-Views-Display",
          "level": 3,
          "text": "Set the Optimal Device for the View’s Display",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "After the view appears, the sample gets the ",
              "type": "text"
            },
            {
              "code": "CGDirectDisplayID",
              "type": "codeVoice"
            },
            {
              "text": " value of the display in which the view appears. The sample uses this identifier to get the Metal device that drives the display.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "// Get the display ID of the display in which the view appears",
            "CGDirectDisplayID viewDisplayID = (CGDirectDisplayID) [_view.window.screen.deviceDescription[@\"NSScreenNumber\"] unsignedIntegerValue];",
            "",
            "// Get the Metal device that drives the display",
            "id<MTLDevice> newPreferredDevice = CGDirectDisplayCopyCurrentMetalDevice(viewDisplayID);"
          ],
          "syntax": "objective-c",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "The sample sets this device for the view controller’s ",
              "type": "text"
            },
            {
              "code": "MTKView",
              "type": "codeVoice"
            },
            {
              "text": ", and chooses the ",
              "type": "text"
            },
            {
              "code": "AAPLRenderer",
              "type": "codeVoice"
            },
            {
              "text": " associated with that same device to perform the app’s rendering.  This setup ensures that the system renders with the device that drives the display, and it avoids copying any drawables from one GPU to another.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "anchor": "Handle-Display-Change-Notifications",
          "level": 3,
          "text": "Handle Display Change Notifications",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "To keep up to date with the optimal device for the view’s display, the sample registers for two system notifications:",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "items": [
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "code": "NSApplicationDidChangeScreenParametersNotification",
                      "type": "codeVoice"
                    },
                    {
                      "text": ". The system posts this notification when the Mac’s display configuration changes. An example is when the user connects or disconnects an external display from the system. Another example is when the GPU driving the display changes, such as when Automatic Graphics Switching is enabled and the system switches between discrete and integrated GPUs to drive the display.",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            },
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "code": "NSWindowDidChangeScreenNotification",
                      "type": "codeVoice"
                    },
                    {
                      "text": ". The system posts this notification when any window, including the window containing the app’s view, moves to a different display.",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            }
          ],
          "type": "unorderedList"
        },
        {
          "code": [
            "// Register for the NSApplicationDidChangeScreenParametersNotification, which triggers",
            "// when the system's display configuration changes",
            "[[NSNotificationCenter defaultCenter] addObserver:self",
            "                                         selector:@selector(handleScreenChanges:)",
            "                                             name:NSApplicationDidChangeScreenParametersNotification",
            "                                           object:nil];",
            "",
            "// Register for the NSWindowDidChangeScreenNotification, which triggers when the window",
            "// changes screens",
            "[[NSNotificationCenter defaultCenter] addObserver:self",
            "                                         selector:@selector(handleScreenChanges:)",
            "                                             name:NSWindowDidChangeScreenNotification",
            "                                           object:nil];"
          ],
          "syntax": "objective-c",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "In both cases, the system calls the sample’s ",
              "type": "text"
            },
            {
              "code": "handleScreenChanges:",
              "type": "codeVoice"
            },
            {
              "text": " method to handle the notification. The sample then chooses the optimal device for the view’s display by selecting the ",
              "type": "text"
            },
            {
              "code": "AAPLRenderer",
              "type": "codeVoice"
            },
            {
              "text": " object that corresponds to the device driving the display.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "anchor": "Set-a-GPU-Eject-Policy",
          "level": 3,
          "text": "Set a GPU Eject Policy",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "By default, macOS fully relaunches an app when an external GPU being used by the app is removed from the system. An app typically handles a relaunch by:",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "items": [
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "text": "Saving as much state as possible when the system calls the app’s ",
                      "type": "text"
                    },
                    {
                      "code": "application:willEncodeRestorableState:",
                      "type": "codeVoice"
                    },
                    {
                      "text": " method, before macOS quits the app.",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            },
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "text": "Restoring any saved state when the system calls the app’s ",
                      "type": "text"
                    },
                    {
                      "code": "application:didDecodeRestorableState:",
                      "type": "codeVoice"
                    },
                    {
                      "text": " method, after macOS relaunches the app.",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            }
          ],
          "type": "orderedList"
        },
        {
          "inlineContent": [
            {
              "text": "The sample avoids this app relaunch routine by instead opting in to handling the external GPU removal itself, without macOS needing to quit and relaunch the app. The sample’s ",
              "type": "text"
            },
            {
              "code": "Info.plist",
              "type": "codeVoice"
            },
            {
              "text": " file has a ",
              "type": "text"
            },
            {
              "code": "GPUEjectPolicy",
              "type": "codeVoice"
            },
            {
              "text": " key with a ",
              "type": "text"
            },
            {
              "code": "wait",
              "type": "codeVoice"
            },
            {
              "text": " value, which indicates that the app will explicitly handle the removal of an external GPU by responding to the corresponding notification posted by Metal.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "anchor": "Register-for-External-GPU-Notifications",
          "level": 3,
          "text": "Register for External GPU Notifications",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "The sample calls the ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.metal/documentation/Metal/MTLCopyAllDevicesWithObserver",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " function to obtain all Metal devices available to the system. This method allows the sample to supply a ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.metal/documentation/Metal/MTLDeviceNotificationHandler",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " block that’s executed when an external GPU is added or removed from the system. This handler provides two arguments:",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "items": [
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "code": "device",
                      "type": "codeVoice"
                    },
                    {
                      "text": ". The device that was added or removed.",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            },
            {
              "content": [
                {
                  "inlineContent": [
                    {
                      "code": "notifyName",
                      "type": "codeVoice"
                    },
                    {
                      "text": ". A value that describes the event that triggered the notification.",
                      "type": "text"
                    }
                  ],
                  "type": "paragraph"
                }
              ]
            }
          ],
          "type": "unorderedList"
        },
        {
          "code": [
            "MTLDeviceNotificationHandler notificationHandler;",
            "",
            "AAPLViewController * __weak controller = self;",
            "notificationHandler = ^(id<MTLDevice> device, MTLDeviceNotificationName name)",
            "{",
            "    [controller markHotPlugNotificationForDevice:device name:name];",
            "};",
            "",
            "// Query all supported metal devices with an observer, so the app can receive notifications",
            "// when external GPUs are added to or removed from the system",
            "id<NSObject> metalDeviceObserver = nil;",
            "NSArray<id<MTLDevice>> * availableDevices =",
            "    MTLCopyAllDevicesWithObserver(&metalDeviceObserver,",
            "                                  notificationHandler);"
          ],
          "syntax": "objective-c",
          "type": "codeListing"
        },
        {
          "anchor": "Respond-to-External-GPU-Notifications",
          "level": 3,
          "text": "Respond to External GPU Notifications",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "The notification handler can execute on any thread. However, all UI updates must occur on the main thread and the app’s state changes must be explicitly made thread-safe. To comply with these thread requirements, the view controller protects access to the ",
              "type": "text"
            },
            {
              "code": "_hotPlugEvent",
              "type": "codeVoice"
            },
            {
              "text": " and ",
              "type": "text"
            },
            {
              "code": "_hotPlugDevice",
              "type": "codeVoice"
            },
            {
              "text": " instance variables with a ",
              "type": "text"
            },
            {
              "code": "@synchronized",
              "type": "codeVoice"
            },
            {
              "text": " directive. (The ",
              "type": "text"
            },
            {
              "code": "@synchronized",
              "type": "codeVoice"
            },
            {
              "text": " directive is a convenient way to create mutex locks in Objective-C code.)",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "The sample sets these instance variables in the ",
              "type": "text"
            },
            {
              "code": "markHotPlugNotificationForDevice:name:",
              "type": "codeVoice"
            },
            {
              "text": " method when a notification occurs.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "- (void)markHotPlugNotificationForDevice:(nonnull id<MTLDevice>)device",
            "                                    name:(nonnull MTLDeviceNotificationName)name",
            "{",
            "    @synchronized(self)",
            "    {",
            "        if ([name isEqualToString:MTLDeviceWasAddedNotification])",
            "        {",
            "            _hotPlugEvent = AAPLHotPlugEventDeviceAdded;",
            "        }",
            "        else if ([name isEqualToString:MTLDeviceRemovalRequestedNotification])",
            "        {",
            "            _hotPlugEvent = AAPLHotPlugEventDeviceEjected;",
            "        }",
            "        else if ([name isEqualToString:MTLDeviceWasRemovedNotification])",
            "        {",
            "            _hotPlugEvent = AAPLHotPlugEventDevicePulled;",
            "        }",
            "",
            "        _hotPlugDevice = device;",
            "    }",
            "}"
          ],
          "syntax": "objective-c",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "The sample reads these instance variables on the main thread and handles the notification in the ",
              "type": "text"
            },
            {
              "code": "handlePossibleHotPlugEvent",
              "type": "codeVoice"
            },
            {
              "text": " method.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "- (void)handlePossibleHotPlugEvent",
            "{",
            "    AAPLHotPlugEvent hotPlugEvent;",
            "    id<MTLDevice> hotPlugDevice;",
            "",
            "    @synchronized(self)",
            "    {",
            "        hotPlugEvent = _hotPlugEvent;",
            "        hotPlugDevice = _hotPlugDevice;",
            "        _hotPlugDevice = nil;",
            "    }",
            "",
            "    if(hotPlugDevice)",
            "    {",
            "        switch (hotPlugEvent)",
            "        {",
            "            case AAPLHotPlugEventDeviceAdded:",
            "                [self handleMTLDeviceAddedNotification:hotPlugDevice];",
            "                break;",
            "            case AAPLHotPlugEventDeviceEjected:",
            "            case AAPLHotPlugEventDevicePulled:",
            "                [self handleMTLDeviceRemovalNotification:hotPlugDevice];",
            "                break;",
            "        }",
            "    }",
            "}"
          ],
          "syntax": "objective-c",
          "type": "codeListing"
        },
        {
          "inlineContent": [
            {
              "text": "When a device that represents an external GPU is added to the system, the ",
              "type": "text"
            },
            {
              "code": "handlePossibleHotPlugEvent",
              "type": "codeVoice"
            },
            {
              "text": " method adds the device to the ",
              "type": "text"
            },
            {
              "code": "_supportedDevices",
              "type": "codeVoice"
            },
            {
              "text": " array and initializes a new ",
              "type": "text"
            },
            {
              "code": "AAPLRenderer",
              "type": "codeVoice"
            },
            {
              "text": " for the device. When such a device is removed from the system, the same method removes the device from the ",
              "type": "text"
            },
            {
              "code": "_supportedDevices",
              "type": "codeVoice"
            },
            {
              "text": " array and destroys its associated ",
              "type": "text"
            },
            {
              "code": "AAPLRenderer",
              "type": "codeVoice"
            },
            {
              "text": ". If the removed device was being used for rendering, the sample switches to another device and renderer.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "anchor": "Update-Per-Frame-State-and-Data",
          "level": 3,
          "text": "Update Per-Frame State and Data",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "MetalKit calls the ",
              "type": "text"
            },
            {
              "identifier": "doc://com.apple.documentation/documentation/MetalKit/MTKViewDelegate/draw(in:)",
              "isActive": true,
              "type": "reference"
            },
            {
              "text": " method for the sample to render each frame. Within this method, the sample calls the ",
              "type": "text"
            },
            {
              "code": "handlePossibleHotPlugEvent",
              "type": "codeVoice"
            },
            {
              "text": " method to handle device additions or removals on the main thread. Such actions include updating UI related to these device events and completing any additional state changes that must be executed atomically on a single thread.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "inlineContent": [
            {
              "text": "The sample then calls the ",
              "type": "text"
            },
            {
              "code": "drawFrameNumber:toView:",
              "type": "codeVoice"
            },
            {
              "text": " to begin rendering a new frame for the current renderer. To ensure continuous rendering that enables seamless switching between different renderers, the sample stores any nonrendering state separate from the renderers themselves. Then, for each frame, the sample passes any necessary nonrendering state to a specific ",
              "type": "text"
            },
            {
              "code": "AAPLRenderer",
              "type": "codeVoice"
            },
            {
              "text": " instance. In this case, the sample passes the current frame number, ",
              "type": "text"
            },
            {
              "code": "_frameNumber",
              "type": "codeVoice"
            },
            {
              "text": ", to the renderer so it can calculate the position and rotation of the sample’s 3D model.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "anchor": "Deregister-from-Notifications",
          "level": 3,
          "text": "Deregister from Notifications",
          "type": "heading"
        },
        {
          "inlineContent": [
            {
              "text": "After the view disappears, the sample explicitly deregisters itself from any previous display or device notifications. Otherwise, the system’s notification center and Metal can’t release the sample’s view controller.",
              "type": "text"
            }
          ],
          "type": "paragraph"
        },
        {
          "code": [
            "- (void)viewDidDisappear",
            "{",
            "    [[NSNotificationCenter defaultCenter] removeObserver:self",
            "                                                    name:NSApplicationDidChangeScreenParametersNotification",
            "                                                  object:nil];",
            "",
            "    [[NSNotificationCenter defaultCenter] removeObserver:self",
            "                                                    name:NSWindowDidChangeScreenNotification",
            "                                                  object:nil];",
            "",
            "    MTLRemoveDeviceObserver(_metalDeviceObserver);",
            "}"
          ],
          "syntax": "objective-c",
          "type": "codeListing"
        },
        {
          "content": [
            {
              "inlineContent": [
                {
                  "text": "The sample can’t defer the deregistration process to the view controller’s ",
                  "type": "text"
                },
                {
                  "code": "dealloc",
                  "type": "codeVoice"
                },
                {
                  "text": " method. When the ",
                  "type": "text"
                },
                {
                  "code": "dealloc",
                  "type": "codeVoice"
                },
                {
                  "text": " method is executed, the system’s notification center and Metal still have references to the view controller that prevent it from being destroyed.",
                  "type": "text"
                }
              ],
              "type": "paragraph"
            }
          ],
          "name": "Note",
          "style": "note",
          "type": "aside"
        }
      ],
      "kind": "content"
    }
  ],
  "references": {
    "187f3109f6d8/SelectingDeviceObjectsForGraphicsRendering.zip": {
      "checksum": "187f3109f6d8540fe18de62af0de44488b91a166495b91ee6b7ddfbdb7224b7a39d3d1532c90d2a884f5a9b5d5a5baee17dd813ad4e438995a57c867682874c6",
      "identifier": "187f3109f6d8/SelectingDeviceObjectsForGraphicsRendering.zip",
      "type": "download",
      "url": "https://docs-assets.developer.apple.com/published/187f3109f6d8/SelectingDeviceObjectsForGraphicsRendering.zip"
    },
    "FastestDrawablePath_BuiltIn": {
      "alt": "A system diagram that shows two possible pathways for a drawable. The recommended pathway renders a drawable with an integrated GPU and presents it on a built-in display. The not recommended pathway renders a drawable with a discrete GPU and transfers it to an integrated GPU before presenting it on a built-in display.",
      "identifier": "FastestDrawablePath_BuiltIn",
      "type": "image",
      "variants": [
        {
          "traits": [
            "1x",
            "light"
          ],
          "url": "https://docs-assets.developer.apple.com/published/dfb4637e8bc81ad32ee2cdd3f52af7d8/FastestDrawablePath_BuiltIn.png"
        }
      ]
    },
    "FastestDrawablePath_External": {
      "alt": "A system diagram that shows two possible pathways for a drawable. The recommended pathway renders a drawable with an external GPU and presents it on an external display. The not recommended pathway renders a drawable with a discrete or integrated GPU and transfers it to an external GPU before presenting it on an external display.",
      "identifier": "FastestDrawablePath_External",
      "type": "image",
      "variants": [
        {
          "traits": [
            "1x",
            "light"
          ],
          "url": "https://docs-assets.developer.apple.com/published/d07ddebc4886354ce8389e6a00378aba/FastestDrawablePath_External.png"
        }
      ]
    },
    "doc://com.apple.documentation/documentation/MetalKit/MTKViewDelegate/draw(in:)": {
      "abstract": [
        {
          "text": "Draws the view’s contents.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "attribute",
          "text": "@"
        },
        {
          "kind": "attribute",
          "preciseIdentifier": "s:ScM",
          "text": "MainActor"
        },
        {
          "kind": "text",
          "text": " "
        },
        {
          "kind": "keyword",
          "text": "func"
        },
        {
          "kind": "text",
          "text": " "
        },
        {
          "kind": "identifier",
          "text": "draw"
        },
        {
          "kind": "text",
          "text": "("
        },
        {
          "kind": "externalParam",
          "text": "in"
        },
        {
          "kind": "text",
          "text": " "
        },
        {
          "kind": "internalParam",
          "text": "view"
        },
        {
          "kind": "text",
          "text": ": "
        },
        {
          "kind": "typeIdentifier",
          "preciseIdentifier": "c:objc(cs)MTKView",
          "text": "MTKView"
        },
        {
          "kind": "text",
          "text": ")"
        }
      ],
      "identifier": "doc://com.apple.documentation/documentation/MetalKit/MTKViewDelegate/draw(in:)",
      "kind": "symbol",
      "role": "symbol",
      "title": "draw(in:)",
      "type": "topic",
      "url": "/documentation/MetalKit/MTKViewDelegate/draw(in:)"
    },
    "doc://com.apple.documentation/documentation/technologies": {
      "abstract": [
        {
          "text": "",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.documentation/documentation/technologies",
      "kind": "technologies",
      "role": "overview",
      "title": "Technologies",
      "type": "topic",
      "url": "/documentation/technologies"
    },
    "doc://com.apple.metal/documentation/Metal": {
      "abstract": [
        {
          "text": "Render advanced 3D graphics and compute data in parallel with graphics processors.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal",
      "kind": "symbol",
      "role": "collection",
      "title": "Metal",
      "type": "topic",
      "url": "/documentation/metal"
    },
    "doc://com.apple.metal/documentation/Metal/MTLCopyAllDevicesWithObserver": {
      "abstract": [
        {
          "text": "Returns an array of all the Metal GPU devices in the system and registers a notification handler that Metal calls when the device list changes.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "identifier",
          "text": "MTLCopyAllDevicesWithObserver"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/MTLCopyAllDevicesWithObserver",
      "kind": "symbol",
      "role": "symbol",
      "title": "MTLCopyAllDevicesWithObserver",
      "type": "topic",
      "url": "/documentation/metal/mtlcopyalldeviceswithobserver"
    },
    "doc://com.apple.metal/documentation/Metal/MTLDeviceNotificationHandler": {
      "abstract": [
        {
          "text": "A Swift closure or an Objective-C block that Metal calls",
          "type": "text"
        },
        {
          "text": " ",
          "type": "text"
        },
        {
          "text": "when the system adds or removes a GPU device.",
          "type": "text"
        }
      ],
      "fragments": [
        {
          "kind": "keyword",
          "text": "typealias"
        },
        {
          "kind": "text",
          "text": " "
        },
        {
          "kind": "identifier",
          "text": "MTLDeviceNotificationHandler"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/MTLDeviceNotificationHandler",
      "kind": "symbol",
      "navigatorTitle": [
        {
          "kind": "identifier",
          "text": "MTLDeviceNotificationHandler"
        }
      ],
      "role": "symbol",
      "title": "MTLDeviceNotificationHandler",
      "type": "topic",
      "url": "/documentation/metal/mtldevicenotificationhandler"
    },
    "doc://com.apple.metal/documentation/Metal/achieving-smooth-frame-rates-with-metal-s-display-link": {
      "abstract": [
        {
          "text": "Pace rendering with minimal input latency while providing essential information to the operating system for power-efficient rendering, thermal mitigation, and the scheduling of sustainable workloads.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/achieving-smooth-frame-rates-with-metal-s-display-link",
      "kind": "article",
      "role": "sampleCode",
      "title": "Achieving smooth frame rates with Metal’s display link",
      "type": "topic",
      "url": "/documentation/metal/achieving-smooth-frame-rates-with-metal-s-display-link"
    },
    "doc://com.apple.metal/documentation/Metal/adjusting-the-level-of-detail-using-metal-mesh-shaders": {
      "abstract": [
        {
          "text": "Choose and render meshes with several levels of detail using object and mesh shaders.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/adjusting-the-level-of-detail-using-metal-mesh-shaders",
      "kind": "article",
      "role": "sampleCode",
      "title": "Adjusting the level of detail using Metal mesh shaders",
      "type": "topic",
      "url": "/documentation/metal/adjusting-the-level-of-detail-using-metal-mesh-shaders"
    },
    "doc://com.apple.metal/documentation/Metal/calculating-primitive-visibility-using-depth-testing": {
      "abstract": [
        {
          "text": "Determine which pixels are visible in a scene by using a depth texture.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/calculating-primitive-visibility-using-depth-testing",
      "kind": "article",
      "role": "sampleCode",
      "title": "Calculating Primitive Visibility Using Depth Testing",
      "type": "topic",
      "url": "/documentation/metal/calculating-primitive-visibility-using-depth-testing"
    },
    "doc://com.apple.metal/documentation/Metal/creating-a-3d-application-with-hydra-rendering": {
      "abstract": [
        {
          "text": "Build a 3D application that integrates with Hydra and USD.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/creating-a-3d-application-with-hydra-rendering",
      "kind": "article",
      "role": "sampleCode",
      "title": "Creating a 3D application with Hydra rendering",
      "type": "topic",
      "url": "/documentation/metal/creating-a-3d-application-with-hydra-rendering"
    },
    "doc://com.apple.metal/documentation/Metal/creating-a-custom-metal-view": {
      "abstract": [
        {
          "text": "Implement a lightweight view for Metal rendering that’s customized to your app’s needs.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/creating-a-custom-metal-view",
      "kind": "article",
      "role": "sampleCode",
      "title": "Creating a Custom Metal View",
      "type": "topic",
      "url": "/documentation/metal/creating-a-custom-metal-view"
    },
    "doc://com.apple.metal/documentation/Metal/culling-occluded-geometry-using-the-visibility-result-buffer": {
      "abstract": [
        {
          "text": "Draw a scene without rendering hidden geometry by checking whether each object in the scene is visible.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/culling-occluded-geometry-using-the-visibility-result-buffer",
      "kind": "article",
      "role": "sampleCode",
      "title": "Culling occluded geometry using the visibility result buffer",
      "type": "topic",
      "url": "/documentation/metal/culling-occluded-geometry-using-the-visibility-result-buffer"
    },
    "doc://com.apple.metal/documentation/Metal/customizing-render-pass-setup": {
      "abstract": [
        {
          "text": "Render into an offscreen texture by creating a custom render pass.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/customizing-render-pass-setup",
      "kind": "article",
      "role": "sampleCode",
      "title": "Customizing Render Pass Setup",
      "type": "topic",
      "url": "/documentation/metal/customizing-render-pass-setup"
    },
    "doc://com.apple.metal/documentation/Metal/encoding-indirect-command-buffers-on-the-cpu": {
      "abstract": [
        {
          "text": "Reduce CPU overhead and simplify your command execution by reusing commands.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/encoding-indirect-command-buffers-on-the-cpu",
      "kind": "article",
      "role": "sampleCode",
      "title": "Encoding Indirect Command Buffers on the CPU",
      "type": "topic",
      "url": "/documentation/metal/encoding-indirect-command-buffers-on-the-cpu"
    },
    "doc://com.apple.metal/documentation/Metal/gpu-devices-and-work-submission": {
      "abstract": [
        {
          "text": "Find any available GPU, submit work to it with command buffers, suspend work, and coordinate between multiple GPUs.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/gpu-devices-and-work-submission",
      "kind": "article",
      "role": "collectionGroup",
      "title": "GPU Devices and Work Submission",
      "type": "topic",
      "url": "/documentation/metal/gpu-devices-and-work-submission"
    },
    "doc://com.apple.metal/documentation/Metal/implementing-order-independent-transparency-with-image-blocks": {
      "abstract": [
        {
          "text": "Draw overlapping, transparent surfaces in any order by using tile shaders and image blocks.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/implementing-order-independent-transparency-with-image-blocks",
      "kind": "article",
      "role": "sampleCode",
      "title": "Implementing Order-Independent Transparency with Image Blocks",
      "type": "topic",
      "url": "/documentation/metal/implementing-order-independent-transparency-with-image-blocks"
    },
    "doc://com.apple.metal/documentation/Metal/improving-edge-rendering-quality-with-multisample-antialiasing-msaa": {
      "abstract": [
        {
          "text": "Use Metal’s MSAA to enhance the rendering of edges with custom resolve options and immediate and tile-based resolve paths.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/improving-edge-rendering-quality-with-multisample-antialiasing-msaa",
      "kind": "article",
      "role": "sampleCode",
      "title": "Improving edge-rendering quality with multisample antialiasing (MSAA)",
      "type": "topic",
      "url": "/documentation/metal/improving-edge-rendering-quality-with-multisample-antialiasing-msaa"
    },
    "doc://com.apple.metal/documentation/Metal/loading-textures-and-models-using-metal-fast-resource-loading": {
      "abstract": [
        {
          "text": "Stream texture and buffer data directly from disk into Metal resources using fast resource loading.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/loading-textures-and-models-using-metal-fast-resource-loading",
      "kind": "article",
      "role": "sampleCode",
      "title": "Loading textures and models using Metal fast resource loading",
      "type": "topic",
      "url": "/documentation/metal/loading-textures-and-models-using-metal-fast-resource-loading"
    },
    "doc://com.apple.metal/documentation/Metal/metal-sample-code-library": {
      "abstract": [
        {
          "text": "Explore the complete set of Metal samples.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/metal-sample-code-library",
      "kind": "article",
      "role": "collectionGroup",
      "title": "Metal Sample Code Library",
      "type": "topic",
      "url": "/documentation/metal/metal-sample-code-library"
    },
    "doc://com.apple.metal/documentation/Metal/multi-gpu-systems": {
      "abstract": [
        {
          "text": "Locate and work with internal and external GPUs and their displays, video memory, and performance tradeoffs.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/multi-gpu-systems",
      "kind": "article",
      "role": "collectionGroup",
      "title": "Multi-GPU Systems",
      "type": "topic",
      "url": "/documentation/metal/multi-gpu-systems"
    },
    "doc://com.apple.metal/documentation/Metal/using-a-render-pipeline-to-render-primitives": {
      "abstract": [
        {
          "text": "Render a simple 2D triangle.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/using-a-render-pipeline-to-render-primitives",
      "kind": "article",
      "role": "sampleCode",
      "title": "Using a Render Pipeline to Render Primitives",
      "type": "topic",
      "url": "/documentation/metal/using-a-render-pipeline-to-render-primitives"
    },
    "doc://com.apple.metal/documentation/Metal/using-metal-to-draw-a-view's-contents": {
      "abstract": [
        {
          "text": "Create a MetalKit view and a render pass to draw the view’s contents.",
          "type": "text"
        }
      ],
      "identifier": "doc://com.apple.metal/documentation/Metal/using-metal-to-draw-a-view's-contents",
      "kind": "article",
      "role": "sampleCode",
      "title": "Using Metal to Draw a View’s Contents",
      "type": "topic",
      "url": "/documentation/metal/using-metal-to-draw-a-view's-contents"
    }
  },
  "sampleCodeDownload": {
    "action": {
      "identifier": "187f3109f6d8/SelectingDeviceObjectsForGraphicsRendering.zip",
      "isActive": true,
      "overridingTitle": "Download",
      "type": "reference"
    },
    "kind": "sampleDownload"
  },
  "schemaVersion": {
    "major": 0,
    "minor": 3,
    "patch": 0
  },
  "sections": [],
  "seeAlsoSections": [
    {
      "anchor": "Render-Workflows",
      "generated": true,
      "identifiers": [
        "doc://com.apple.metal/documentation/Metal/using-metal-to-draw-a-view's-contents",
        "doc://com.apple.metal/documentation/Metal/using-a-render-pipeline-to-render-primitives",
        "doc://com.apple.metal/documentation/Metal/customizing-render-pass-setup",
        "doc://com.apple.metal/documentation/Metal/creating-a-custom-metal-view",
        "doc://com.apple.metal/documentation/Metal/calculating-primitive-visibility-using-depth-testing",
        "doc://com.apple.metal/documentation/Metal/encoding-indirect-command-buffers-on-the-cpu",
        "doc://com.apple.metal/documentation/Metal/implementing-order-independent-transparency-with-image-blocks",
        "doc://com.apple.metal/documentation/Metal/loading-textures-and-models-using-metal-fast-resource-loading",
        "doc://com.apple.metal/documentation/Metal/adjusting-the-level-of-detail-using-metal-mesh-shaders",
        "doc://com.apple.metal/documentation/Metal/creating-a-3d-application-with-hydra-rendering",
        "doc://com.apple.metal/documentation/Metal/culling-occluded-geometry-using-the-visibility-result-buffer",
        "doc://com.apple.metal/documentation/Metal/improving-edge-rendering-quality-with-multisample-antialiasing-msaa",
        "doc://com.apple.metal/documentation/Metal/achieving-smooth-frame-rates-with-metal-s-display-link"
      ],
      "title": "Render Workflows"
    }
  ],
  "variantOverrides": [
    {
      "patch": [
        {
          "op": "replace",
          "path": "/identifier/interfaceLanguage",
          "value": "occ"
        },
        {
          "op": "add",
          "path": "/topicSections",
          "value": null
        },
        {
          "op": "replace",
          "path": "/seeAlsoSections",
          "value": [
            {
              "anchor": "Render-Workflows",
              "generated": true,
              "identifiers": [
                "doc://com.apple.metal/documentation/Metal/using-metal-to-draw-a-view's-contents",
                "doc://com.apple.metal/documentation/Metal/using-a-render-pipeline-to-render-primitives",
                "doc://com.apple.metal/documentation/Metal/customizing-render-pass-setup",
                "doc://com.apple.metal/documentation/Metal/creating-a-custom-metal-view",
                "doc://com.apple.metal/documentation/Metal/calculating-primitive-visibility-using-depth-testing",
                "doc://com.apple.metal/documentation/Metal/encoding-indirect-command-buffers-on-the-cpu",
                "doc://com.apple.metal/documentation/Metal/implementing-order-independent-transparency-with-image-blocks",
                "doc://com.apple.metal/documentation/Metal/loading-textures-and-models-using-metal-fast-resource-loading",
                "doc://com.apple.metal/documentation/Metal/adjusting-the-level-of-detail-using-metal-mesh-shaders",
                "doc://com.apple.metal/documentation/Metal/creating-a-3d-application-with-hydra-rendering",
                "doc://com.apple.metal/documentation/Metal/culling-occluded-geometry-using-the-visibility-result-buffer",
                "doc://com.apple.metal/documentation/Metal/improving-edge-rendering-quality-with-multisample-antialiasing-msaa",
                "doc://com.apple.metal/documentation/Metal/achieving-smooth-frame-rates-with-metal-s-display-link"
              ],
              "title": "Render Workflows"
            }
          ]
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.documentation~1documentation~1MetalKit~1MTKViewDelegate~1draw(in:)/title",
          "value": "drawInMTKView:"
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.documentation~1documentation~1MetalKit~1MTKViewDelegate~1draw(in:)/fragments",
          "value": [
            {
              "kind": "text",
              "text": "- ("
            },
            {
              "kind": "typeIdentifier",
              "preciseIdentifier": "c:v",
              "text": "void"
            },
            {
              "kind": "text",
              "text": ") "
            },
            {
              "kind": "identifier",
              "text": "drawInMTKView:"
            },
            {
              "kind": "text",
              "text": "("
            },
            {
              "kind": "typeIdentifier",
              "preciseIdentifier": "c:objc(cs)MTKView",
              "text": "MTKView"
            },
            {
              "kind": "text",
              "text": " *) "
            },
            {
              "kind": "internalParam",
              "text": "view"
            },
            {
              "kind": "text",
              "text": ";"
            }
          ]
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.metal~1documentation~1Metal~1MTLDeviceNotificationHandler/title",
          "value": "MTLDeviceNotificationHandler"
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.metal~1documentation~1Metal~1MTLDeviceNotificationHandler/fragments",
          "value": [
            {
              "kind": "identifier",
              "text": "MTLDeviceNotificationHandler"
            }
          ]
        },
        {
          "op": "replace",
          "path": "/references/doc:~1~1com.apple.metal~1documentation~1Metal~1MTLDeviceNotificationHandler/navigatorTitle",
          "value": [
            {
              "kind": "identifier",
              "text": "MTLDeviceNotificationHandler"
            }
          ]
        }
      ],
      "traits": [
        {
          "interfaceLanguage": "occ"
        }
      ]
    }
  ],
  "variants": [
    {
      "paths": [
        "/documentation/metal/selecting-device-objects-for-graphics-rendering"
      ],
      "traits": [
        {
          "interfaceLanguage": "swift"
        }
      ]
    },
    {
      "paths": [
        "/documentation/metal/selecting-device-objects-for-graphics-rendering"
      ],
      "traits": [
        {
          "interfaceLanguage": "occ"
        }
      ]
    }
  ]
}
